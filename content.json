[{"title":"googel-guava-生产问题","date":"2017-06-21T09:13:07.000Z","path":"2017/06/21/google-guava/googel-guava-生产问题/","text":"Google Guava实际开发遇到的问题总结 Guava Lists.transform dubbo请求序列化问题问题引发今天遇到一个问题，大概是这样的：使用了guava的Lists.transform对一个ArrayList进行转化后，做一个dubbo的请求参数，发生异常。但是使用原生态的ArrayList是没问题的。 在实际工作中我们经常对一个List集合进行转化，常用的就是for循环和forEach。google Guava提供的 transform可以做到更优雅。看例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344//TODO 批量缓存圈子信息private Map&lt;String,String&gt; cacheGomeShopGroupItem(List&lt;GomeStoreItem&gt; gomeStoreItems)&#123; final Map&lt;String,String&gt; shopGroupMap = Maps.newHashMap(); //1、普通for循环 List&lt;String&gt; storeIds = Lists.newArrayList(); for (int i = 0; i &lt;gomeStoreItems.size()&amp;&amp;gomeStoreItems!=null ; i++) &#123; GomeStoreItem gomeStoreItem = gomeStoreItems.get(i); String storeId = null; if (gomeStoreItem != null)&#123; storeId = gomeStoreItem.getGomeStoreId(); &#125; storeIds.add(storeId); &#125; //2、使用transform转化 List&lt;String&gt; storeIds1 = Lists.newArrayList(); storeIds1.addAll(Lists.transform(gomeStoreItems, new Function&lt;GomeStoreItem, String&gt;() &#123; @Nullable @Override public String apply(@Nullable GomeStoreItem gomeStoreItem) &#123; return gomeStoreItem.getGomeStoreId(); &#125; &#125;)); List&lt;GomeShopGroupItem&gt; shopGroupItems = Lists.newArrayList(); try &#123; //正常的dubbo调用 CommonResultEntity&lt;List&lt;ShopGroupInfo&gt;&gt; resuletEntity = opensocialGroupFacade.shopGroupInfo(storeIds); //非正常的dubbo调用 CommonResultEntity&lt;List&lt;ShopGroupInfo&gt;&gt; resuletEntity1 = opensocialGroupFacade.shopGroupInfo(storeIds1); // 业务代码 ...... &#125; catch (Exception e) &#123; logger.error(String.format(\"查询圈子出错：storeIds：%s\",JSON.toJSONString(storeIds))); &#125; return shopGroupMap; &#125; 问题分析以下是使用transform转化的List,使用dubbo调用发生的异常信息： 12Failed to invoke the method shopGroupInfo in the service cn.com.mx.opensocial.group.service.IOpensocialGroupFacade. Tried 3 times of the providers [10.125.198.49:30006] (1/1) from the registry 10.125.198.74:2181 on the consumer 10.144.36.140 using the dubbo version 2.5.5.cat-SNAPSHOT. Last error is: Failed to invoke remote method: shopGroupInfo, provider: dubbo://10.125.198.49:30006/cn.com.mx.opensocial.group.service.IOpensocialGroupFacade?anyhost=true&amp;application=gome-detail-service&amp;check=false&amp;default.accepts=1000&amp;default.check=false&amp;default.timeout=5000&amp;dubbo=2.5.3&amp;heartbeat=100000&amp;interface=cn.com.mx.opensocial.group.service.IOpensocialGroupFacade&amp;methods=shopGroupInfo,strollGroups,checkIsMember&amp;owner=qiantai&amp;pid=4876&amp;providerside=venus-opensocial&amp;revision=1.1&amp;serialization=nativejava&amp;side=consumer&amp;timeout=8000&amp;timestamp=1498030003360&amp;version=1.0.0, cause: Failed to send message Request [id=12, version=2.0.0, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=shopGroupInfo, parameterTypes=[interface java.util.List], arguments=[[1, 6, 10, 20, 30, 31, 40, 10122, 10132, 10138, 10140, 10142, 10145, 10146, 10150, 10159]], attachments=&#123;_catChildMessageId=gome-detail-service-0a90248c-416119-487610019, _catParentMessageId=gome-detail-service-0a90248c-416119-487610018, _rStrategy=null, path=cn.com.mx.opensocial.group.service.IOpensocialGroupFacade, consumerside=gome-detail-service, interface=cn.com.mx.opensocial.group.service.IOpensocialGroupFacade, _catRootMessageId=gome-detail-service-0a90248c-416119-487610018, @null=null, timeout=8000, version=1.0.0&#125;]] to /10.125.198.49:30006, cause: com.gome.item.services.GomeStoreServiceImpl$2 cause: Failed to send message 可以看出发送请求的时候就失败了。那么第一考虑到的就是序列化，因为一次rpc调用肯定需要将参数序列化。 1、ArrayList 实现了 java.io.Serializable接口；2、使用transform生成的TransformingRandomAccessList 并不是ArrayList类型并没有实现序列化接口， 带着问题去查看guava源码：123456789101112/** * Returns a list that applies &#123;@code function&#125; to each element of &#123;@code * fromList&#125;. The returned list is a transformed view of &#123;@code fromList&#125;; * changes to &#123;@code fromList&#125; will be reflected in the returned list and vice * versa. * * &lt;p&gt;Since functions are not reversible, the transform is one-way and new * items cannot be stored in the returned list. The &#123;@code add&#125;, * &#123;@code addAll&#125; and &#123;@code set&#125; methods are unsupported in the returned * list. ........ */ 大概意思：123456/** * 该方法返回一个列表，这个列表中元素是运用方法中传入的功能函数(Function)对原列表中的元素进行处理后的结果, * 它是原列表的一个功能视图，任何对原列表的改变将会体现到视图列表中。因为Function函数是不可逆的， * 所以这样的转换是单向的，并且转换的结果不能存储在返回的列表中。 * 所有对视图列表的添加（add/addAll）、设置（set）等都是不被支持的。 */ 所以说，返回的对象列表是一个视图，其中对它的任何更改都是无效的，并且也不建议对视图对象产生更改，如果需要更改返回的列表，那么需要自己进一步包装，如Lists.newArrayList(retList);如果需要对返回的结果视图进行处理：12List&lt;String&gt; storeIdsArrayList = Lists.newArrayList(storeIds); 这样就可以正常的去做为一个rpc请求的参数了。","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"//star45.me/tags/Guava/"}]},{"title":"SpringBoot 1","date":"2017-05-13T04:02:45.000Z","path":"2017/05/13/spring/SpringBoot/","text":"SpringBoot 学习 springboot 整合dubbo使用 xml方式。 用Dubbo做过几个项目了，从来没有碰到过Caused by: Java.lang.ClassCastException这种错误，最后经过反复的测试发现原来是因为依赖了SpringBoot的开发者工具才出现的这一个问题，只要把下面的依赖去掉就解决了这一个问题： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1. 如果你需要在SpringApplication初始化的时候就做一些事情，使用ApplicationContextInitializer 如果你需要SpringApplication的某个特定阶段做一些事情，使用ApplicationListener（推荐） 如果你需要在beanFactory层面上开发，使用BeanFactoryPostProcessor（推荐） 如果你需要在对某个bean的实例化层面上开发，使用BeanPostProcessor（一般业务上的开发使用InitializingBean或者init-method能够满足）","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"//star45.me/tags/SpringBoot/"}]},{"title":"google-guava-functional","date":"2017-04-19T09:18:21.000Z","path":"2017/04/19/google-guava/google-guava4-functional/","text":"Google Guava学习 google-guava-functional 我们为什么要用google-guava-functional google-guava-functional 会给我们带来什么 我们带着这些问题，去认识、学习google-guava-functional","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"//star45.me/tags/Guava/"}]},{"title":"google-guava-caches","date":"2017-04-19T09:18:00.000Z","path":"2017/04/19/google-guava/google-guava3-caches/","text":"Google Guava学习 google-guava-caches 我们为什么要用google-guava-caches google-guava-caches会给我们带来什么 我们带着这些问题，去认识、学习google-guava-caches","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"//star45.me/tags/Guava/"}]},{"title":"google-guava-collections","date":"2017-04-19T09:17:35.000Z","path":"2017/04/19/google-guava/google-guava2-collections/","text":"GoogleGuava学习 google-guava-collections是什么 我们为什么要用google-guava-collections google-guava-collections会给我们带来什么 我们带着这些问题，去认识、学习google-guava-collections 使用Guava里的Collections，你将受益不菲。它能大量减少你工程里那些样本式的代码 (同时你还能使用它提供的新的速度更快的数据结构！). Google Collection 实现实际开发应用 题外话：前几天开发一个功能的时候，需要一个复杂的数据接口。一个Map里面key-value结构，value的值是使用List。还需要排序、遍历检索等操作，虽然在机器中的运算是比较快的，但是整体的代码比较臃肿。这时候在review同事的代码中发现一个优秀的类库google-guava中的collection。一旦上手发现太爽了。 123456Multimap&lt;Integer, WarrantyBean&gt; warrantyMultimap = ArrayListMultimap.create();for (WarrantyBean warrantyBean : result)&#123; Integer typeKey = warrantyBean.getProductWarrantyType(); warrantyMultimap.put(typeKey,warrantyBean);&#125;Map&lt;Integer,Collection&lt;WarrantyBean&gt;&gt; warrantyMap = warrantyMultimap.asMap(); 这样可以在一次for循环中得到一个Map","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"//star45.me/tags/Guava/"}]},{"title":"google-guava1-basic","date":"2017-04-19T09:13:07.000Z","path":"2017/04/19/google-guava/google-guava1-basic/","text":"Google Guava学习 google-guava 我们为什么要用google-guava google-guava 会给我们带来什么 我们带着这些问题，去认识、学习google-guava","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"//star45.me/tags/Guava/"}]},{"title":"面试","date":"2017-03-28T08:15:24.000Z","path":"2017/03/28/杂事/面试/","text":"一些java面试问题总结 Java基础 Hashtable和HashMap的区别。 抽象类与接口的区别。 final关键字的使用和区别。 异常分类和处理机制。 JDK版本区别。 StringBuilder内部实现机制。 反射机制的使用。 匿名内部类的使用。 泛型的概念和使用。 弱引用和虚引用的概念和使用方式。 开源框架 SpringMVC和Struts2的区别 Spring IOC和AOP的概念以及实现方式 Spring事务的管理 Hibernate与MyBatis的比较 Hibernate延迟加载的机制 JVM虚拟机 GC算法有哪些 垃圾回收器有哪些 如何调优JVM 缓存和NoSQL 缓存的使用场景 缓存命中率的计算 Memcache与Redis的比较 如何实现Redis的分片 MongoDB的特点 分布式 zookeeper的用途 dubbo的用途以及优点 dubbo的实现原理 数据结构和算法 单向链表的逆序排列 双向链表的操作 1亿个整数的倒序输出 找出给定字符串中最长回文（回文：abcdcba，两端对称） 网络编程 Get和Post的区别 Https协议的实现 长连接的管理 Socket的基本方法 数据库 inner join和left join的区别 复杂SQL语句 数据库优化方式 数据库拆分方式 如何保证不同数据结构的数据一致性 安全 什么是XSS攻击，具体如何实现？开放问题：如何保障系统安全？ 设计模式 写出一个设计模式的类图 设计模式的意义是什么 写个单例模式的代码 多线程 如何避免Quartz重复启动任务 线程池满了如何处理额外的请求 同一个对象的连个同步方法能否被两个线程同时调用 华丽丽的分割线 部分答案Java基础 HashMap和Hashtable的区别 HashMap是非线程安全的，Hashtable是线程安全的。 HashMap的键值都可以为null，Hashtable的键值都不可以为null值。 HashMap继承自AbstractMap类，Hashtable继承自Dictionary类。 ps : Properties类继承自Hashtable类。 异常分类和处理机制 分类： 运行时异常（Runtime Exception） 受检查异常（Checked Exception） 运行时异常： 必须继承RuntimeException类， 定义方法时不必声明会抛出运行时异常。 调用方法时不必捕获运行时异常。 受检查异常： 不继承自RumtimeException类 定义方法时需要抛出可能会抛出的Checked Exception 调用方法时需要捕获Checked Exception或者继续向上抛出。 逻辑上： 运行时异常：一般不需要或者不知道如何处理此类异常； 受检验异常：一般需要知道如何处理可能发生的异常情况。 StringBuilder内部实现机制 StringBuilder内部有一个字符数组，代码如下: char[] value; //字符数组 int count; //字符串长度 每一次append操作都是将新的字符串加入到可变长的字符数组中，长度计算方式与ArrayList类似。调用toString()方法时，new一个String对象即可。 123public String toString() &#123; return new String(value, 0, count);// Create a copy, don't share the array&#125; ps: StringBuffer是线程安全的，StringBuilder是非线程安全的。 匿名内部类的使用 匿名内部类是没有名字的类，只在某一处被使用，不会被多处调用，一般是某个父类或接口的特定实现。 强引用、软引用、弱引用和虚引用 强引用: 一般的引用都是强引用，即使OutOfMemory也不会回收这部分被把持的引用内存。 软引用（SoftReference）: 如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被使用。++软引用可以用来实现内存敏感的高速缓存。++ 弱引用（WeakReference）：弱引用的对象拥有更短暂的生命周期。当垃圾回收期发现只有若引用的对象，不论内存空间足够与否，都会回收它。 虚引用（）：虚引用不会决定对象的生命周期，如果一个对象仅持有一个虚引用，那么它随时可能被回收。++虚引用主要用来跟踪对象被垃圾回收器回收的活动。++ 更多关于『强、软、弱和虚引用』参考文章：http://zhangjunhd.blog.51cto…. 开源框架 SpringMVC和Struts2的区别 SpringMVC的方法级别的拦截，Struts2是类级别的拦截； SpringMVC是基于Servlet实现Controller，Struts2是基于Filter实现； SpringMVC性能和安全性高于Struts2； SpringMVC更加组件化和流程化，易于扩展，比如返回JSON通过设置@ResponseBody即可； Struts2更加无耦合，比较纯粹，但是需要更多的自行开发的代码以支持更多功能。 Spring事务的管理 分类：声明式事务、编程式事务 声明式事务：通过统一配置实现事务的统一管理，一般配置TransactionMananger以及相关属性即可。 编程式事务（注解方式）：在需要事务的方法上配置相关的注解（包括事务类型、回滚策略等） 事务类型： PROPAGATION_REQUIRED PROPAGATION_SUPPORTS3.PROPAGATION_MANDATORY PROPAGATION_REQUIRES_NEW PROPAGATION_NOT_SUPPORTED PROPAGATION_NEVER PROPAGATION_NESTED 事务隔离级别 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE Hibernate与MyBatis的比较 Hibernate完全实现对象关系映射（ORM），MyBatis实现的是SQL Mapping MyBatis可以进行更为细致的SQL优化，可以减少查询字段。比Hibernate容易掌握，Hibernate门槛较高。 Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。 Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。 Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。 Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。 JVM虚拟机 GC算法有哪些 引用计数 复制 标记-清除 标记-压缩 分代（新生代、老年代、永久代） 垃圾回收器有哪些 串行回收器：新生代串行回收器、老年代串行回收器 并行回收器：新生代ParNew回收器、新生代ParallelGC回收器、老年代ParallelGC回收器 CMS回收器：（Concurrent Mark Sweep、并发标记清除） G1回收器（1.7以后代替CMS回收器） 如何调优JVM 标准参数： -client -server模式 -Xmn、-Xms、-Xmx 监控：jps、jstat、jinfo、jmap、jhat、jstack… Java 中堆和栈有什么区别？ JVM 中堆和栈属于不同的内存区域，使用目的也不同。 栈常用于保存方法帧和局部变量，而对象总是在堆上分配。 栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。 缓存和NoSQL 缓存命中率的计算 命中缓存次数/(命中缓存次数+未命中缓存次数) = 命中率 Memcache与Redis的区别 memcache把数据存在内存之中，断电后会挂掉；Redis部分数据持久化在硬盘上，断电不会丢失。 memcache存的是key-value对，redis支持更多的数据结构和数据类型 memcache可以使用一致性hash做分布式，redis可以做主从同步 redis单线程，只使用1个cpu 如何实现Redis的分片 使用一致性哈希对数据进行映射 实现方式：客户端分片（每个客户端对应一个分片）、代理协助分片、查询路由分片； 使用redis集群，如codis（豌豆荚，依赖zookeeper）； 分布式 zookeeper的用途 zookeeper作为分布式应用协调系统，已经用到很多分布式项目中。可以用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项等管理工作。 zookeeper的主要操作分一下几种： 创建节点 读取节点数据 更新节点数据 删除节点 监控节点变化 应用场景： 统一命名服务，使用create自动创建节点编号； 配置管理，多个节点的共享配置，当配置发生变化时，可利用zookeeper让使用这些配置的节点获得通知，进行重新加载等操作。如dubbo服务。 集群管理：集群选举主节点，资源定位。 共享锁 负载均衡 应用项目：dubbo服务集群、redis集群、Hadoop集群等 dubbo的用途以及优点 Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。 数据结构和算法 将单项链表逆序排列 将单向链表逆序输出，方法有三种： 遍历链表，将每个节点的内容存入一个数组中，然后逆序输出数组(最简单的做法) 使用栈来逆序输出 直接将链表（指针）逆序然后输出 单向链表详细信息参考文章：http://blog.csdn.net/jianyuer… 海量数据操作 十道面试题与十个海量数据处理方法总结 http://blog.csdn.net/v_july_v/article/details/6279498","tags":[{"name":"Java","slug":"Java","permalink":"//star45.me/tags/Java/"}]},{"title":"Spring系列1-Filter","date":"2017-03-13T04:02:45.000Z","path":"2017/03/13/spring/Spring系列1-Filter/","text":"SpringFramework学习 Spring提供的Filter 是什么 我们为什么要用Spring提供的Filter Spring提供的Filter 会给我们带来什么 我们带着这些问题，去认识、学习Spring提供的Filter过滤器 Spring Framework 是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，以Apache许可证形式发布，也有.NET平台上的移植版本。该框架基于 Expert One-on-One Java EE Design and Development（ISBN 0-7645-4385-7）一书中的代码，最初由Rod Johnson和Juergen Hoeller等开发。Spring Framework提供了一个简易的开发方式，这种开发方式，将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类。 Spring提供的filter有如下这些，list filter: AbstractRequestLoggingFilter CharacterEncodingFilter CommonsRequestLoggingFilter CompositeFilter DelegatingFilterProxy GenericFilterBean HiddenHttpMethodFilter HttpPutFormContentFilter Log4jNestedDiagnosticContextFilter OncePerRequestFilter RequestContextFilter ServletContextRequestLoggingFilter ShallowEtagHeaderFilter 一、CharacterEncodingFilterCharacterEncodingFilter主要用于处理请求中的乱码问题。 这个类的继承关系如下： CharacterEncodingFilter的部分源码： 123456789101112131415161718public class CharacterEncodingFilter extends OncePerRequestFilter &#123; private String encoding; private boolean forceEncoding = false; @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response); &#125;&#125; forceEncoding 为 true 为设置response的编码，并不会对request参数造成影响。 使用例子： 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Spring","slug":"Spring","permalink":"//star45.me/tags/Spring/"}]},{"title":"Spring系列1-Filter","date":"2017-03-13T04:02:45.000Z","path":"2017/03/13/spring/Spring系列2-Ioc/","text":"SpringFramework学习 Spring Ioc 是什么 我们为什么要用Spring Ioc Spring Ioc 会给我们带来什么 我们带着这些问题，去认识、学习Spring Ioc ## Spring Framework 是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，以Apache许可证形式发布，也有.NET平台上的移植版本。该框架基于 Expert One-on-One Java EE Design and Development（ISBN 0-7645-4385-7）一书中的代码，最初由Rod Johnson和Juergen Hoeller等开发。Spring Framework提供了一个简易的开发方式，这种开发方式，将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类。 1. IoC理论的背景耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品spring。 2. 什么是控制反转(IoC)IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。 我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。 3. IOC的别名：依赖注入(DI)依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。 4. IOC为我们带来了什么好处 组件之间低耦合或者无耦合带来的好处。 5. IOC容器的技术剖析IOC中最基本的技术就是“反射(Reflection)”编程 ##待更新##","tags":[{"name":"framework","slug":"framework","permalink":"//star45.me/tags/framework/"},{"name":"Spring","slug":"Spring","permalink":"//star45.me/tags/Spring/"}]},{"title":"github维护","date":"2017-01-11T10:12:17.000Z","path":"2017/01/11/工具/github维护/","text":"关于github的学习管理 github的一些操作 一、建立项目二、导入项目三、使用git维护四、编写readme.md1、使用MarkDown2、个性的图标http://shields.io/ 项目介绍 Star 项目版本 项目构建 项目覆盖 项目许可 项目下载","tags":[{"name":"Github","slug":"Github","permalink":"//star45.me/tags/Github/"}]},{"title":"Linux下shell脚本执行jar文件","date":"2017-01-11T10:11:51.000Z","path":"2017/01/11/服务器/Linux下shell脚本执行jar文件/","text":"使用shell脚本执行一些命令 以下是具体的命令脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/bin/bash#description: 启动重启server服务 #端口号，根据此端口号确定PID PORT=9997 #启动命令所在目录 HOME='/usr/etc/server/java/server' #查询出监听了PORT端口TCP协议的程序 pid=`netstat -anp|grep $PORT|awk '&#123;printf $7&#125;'|cut -d/ -f1` start()&#123; if [ -n \"$pid\" ]; then echo \"server already start,pid:$pid\" return 0 fi #进入命令所在目录 cd $HOME nohup java -jar $HOME/pserver9997.jar &gt; $HOME/server.log 2&gt;&amp;1 &amp; #启动聊天服务器 把日志输出到HOME目录的server.log文件中 echo \"start at port:$PORT\" &#125; stop()&#123; if [ -z \"$pid\" ]; then echo \"not find program on port:$PORT\" return 0 fi #结束程序，使用讯号2，如果不行可以尝试讯号9强制结束 kill -9 $pid rm -rf $pid echo \"kill program use signal 2,pid:$pid\" &#125; status()&#123; if [ -z \"$pid\" ]; then echo \"not find program on port:$PORT\" else echo \"program is running,pid:$pid\" fi &#125; case $1 in start) start ;; stop) stop ;; restart) $0 stop sleep 2 $0 start ;; status) status ;; *) echo \"Usage: &#123;start|stop|status&#125;\" ;; esac exit 0","tags":[{"name":"Linux","slug":"Linux","permalink":"//star45.me/tags/Linux/"}]},{"title":"Sublime Text 3 《第四章 - 插件》","date":"2017-01-11T10:11:25.000Z","path":"2017/01/11/工具/Sublime-Text-3-《第四章-插件》/","text":"工欲善其事，必先利其器四、Sublime Text 3 插件详解 插件列表: SideBarEnhancements : 左侧菜单栏 Anaconda : Python集成插件 ConvertToUTF8 : 非utf8文本自动转换 BetterCoffeeScript : Coffee支持 emmet : ZenCoding Markdown preview : markdown预览 MarkdownEditing : markdown高亮 Gutter Color : 显示颜色，需要先运行brew install ImageMagick terminal : 直接打开终端 Git : 直接使用Git命令(当然要先有git) 各种格式化的插件就按照自己的需求选装吧 安装完成后，一个绝对不会卡的轻便IDE就完成了！ 1、SublimeTmpl Sublime Text 新建文件的模版插件: SublimeTmpl写了个sublime的模版插件, 项目主页: https://github.com/kairyou/SublimeTmpl 这样就可以新建文件时使用模版的内容了, 目前添加了 1* html js css php python ruby 六种模版. 不需新建空白文件, 再从其他文件复制内容过来了. 已增加对Sublime Text3的支持. 使用: 11. ST菜单, File-New File (SublimeTmpl), 选择列表里的相应菜单, 可直接使用模版新建文件. 命令, cmd+shift+p, 输入: “tmpl:”, 可以找到创建文件的菜单列表. 快捷键, 默认快捷键见下面. 可以自己修改, 方法见”设置”部分. 默认快捷键: | 快捷键 | 目标文件 || — | — || ctrl+alt+h | html || ctrl+alt+j | javascript || ctrl+alt+c | css || ctrl+alt+p | php || ctrl+alt+r | ruby || ctrl+alt++shift+p | python | 安装: 11\\. 方法1\\. 通过 Package Control Package Control / Install Package, 搜索”SublimeTmpl” 或 “tmpl”, 安装.已经通过Package Control审核 12\\. 方法2\\. Github 打开项目主页, Git clone到ST的Packages文件夹(\\Data\\Packages), 或直接把ZIP格式的下载下来解压到Packages文件夹(文件夹名称必须为:SublimeTmpl). 设置: 菜单: Preferences / Packages Settings / SublimeTmpl, 可以编辑菜单/快捷键/新语法等等. 如果你想贡献自己的package, 可以参考我这篇文章的介绍:http://www.fantxi.com/blog/archives/how-to-submit-a-sublime-package/ 新增特性: 11. 用户自定义模板 (Thanks @Xu Cheng Github) 自定义模板路径: “Data\\Packages\\User\\SublimeTmpl\\templates” 目录, 会优先使用.默认模版路径: “Data\\Packages\\SublimeTmpl\\templates” 目录.用自己自定义的模板: 推荐把默认模版目录的*.tmpl文件 复制到 自定义模板路径, 再去修改. 12. 模板支持 $&#123;date&#125; 变量 settings - user里面可以修改${date}默认的输出格式(“%Y-%m-%d %H:%M:%S”), 比如改成: “date_format” : “%Y-%m-%d” 13\\. 模板支持自定义 attr settings - user里添加: 12345\"attr\": &#123;\"author\": \"your name\" ,\"email\": \"mail@yours.com\",\"link\": \"http://yours.com\",\"hello\": \"word\" }`就能在模板中使用 author{email} link{hello} 变量Thanks @vfasky (Blog) 另外, 关于新增语言的附加说明 11\\. 新增SublimeTmpl里面没有的语言 首先请看: Packages Settings / SublimeTmpl / Settings - Default 的默认语法设置.如果要新增语法, 请选择: SublimeTmpl / Settings - User, 内容格式参考Settings - Default的内容, 比如新增两个语言test和yours: ` { &quot;test&quot;: {&quot;syntax&quot;: &quot;Packages/test/test.tmLanguage&quot;}, &quot;yours&quot;: {&quot;syntax&quot;: &quot;Packages/Yours/Yours.tmLanguage&quot;} } ` ` 新增开始菜单: 可以在SublimeTmpl / Settings - Menu里, 参照其他语法增加test和yours. 新增快捷键: 可以编辑:SublimeTmpl / Key Bindings User( 格式参考: SublimeTmpl / Key Bindings Default) 新增Sublime的语言 1234567这个我也没新建过, 可以去Package Control或者github上面找个其他人添加的新语言, 参考参考.如果没找到别人写好的, 可以参考如下网址, 自己做:1. [官方文档][1], 利用AAAPackageDev这个插件制作2. [textmate的doc][2], 和sublime大部分是相同的3. [语法][3], 可以和自己新建的对比4. [详解][4]，很全面的教程 四、快捷键（只针对目前的软件） ctrl+alt+f格式化js代码 —— jsFormat tabhtml提示 ——- emmet 随心所欲的跳转Cmd+P之所以被叫做 Goto Anything 并不是虚名： 1* `Command+P` 可以快速跳转到当前项目中的任意文件，可进行关键词匹配。 Command+P后@(或是Command+R)可以快速列出/跳转到某个函数（很爽的是markdown 当中是匹配到标题，而且还是带缩进的！）。 Command+P后#可以在当前文件中进行搜索。 Command+P后 : (或是Ctrl+G)加上数字可以跳转到相应的行。而更酷的是你可以用Command+P加上一些关键词跳转到某个文件同时加上 @ 来列出/跳转到目标文件中的某个函数，或是同时加上 # 来在目标文件中进行搜索，或是同时加上 : 和数字来跳转到目标文件中相应的行。 以下是个人总结不完全的快捷键总汇，祝愿各位顺利解放自己的鼠标。 选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和Gtrl+Z一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类 Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+：打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式 五、开发环境1、java开发环境2、Python开发环境 SublimeREPL，REPL就是read-evaluation-print-loop，解释型语言编译运行的过程）。装了SublimeREPL插件后也支持了编辑器上直接的编译运行和交互，但还是有一些不满的地方。SublimeREPL提供的功能当中有两个我比较常用的是运行Python交互环境和直接运行当前文件，而python自带的IDLE跟人性化的做法是把这两者结合起来，所以我想实现的是对当前的文件运行python的交互环境。 SublimeREPL 允许你在编辑界面直接运行 Python 解释器。我倾向于在单独的终端窗口用 bpython 来运行，但有时 SublimeREPL 是很有帮助的。 Pylinter 这个插件提供了目前我所见到的最好的 pylint 编辑器整合。它自动检查 .py 文件，无论其何时被保存，并且会直接在编辑界面显示 pylint 违规。它还有一个快捷方式来禁用局部的 pylint 检查，通过插入一个 #pylint: 禁用注释。这个插件对于我确实非常有用。 Anaconda绝对是换到Sublime Text 3后最令我兴奋的插件，没有之一。在Sublime Text 2的时代，为配置一个好用的python开发环境， 我们需要分别安装All Autocomplete,SublimeREPL,Pylinter和PEP8等诸多插件。 Geek就是让一切变得更简单，该插件作者就为了简便，把这些功能集中起来了。 Anaconda把PyFlakes, pep8 和 McCabe以插件的方式集成起来。安装Anaconda后，通过配置即可完成一个良好的Python开发环境。 3、markdown环境 markdown支持 http://www.ihunter.me/sublime-text-3%E4%B8%AD%E9%85%8D%E7%BD%AEmarkdown.html 4、git环境版本库是软件开发中不可缺少的工具，该插件把Git常用命令加入了Command Palette，让开发人员进行代码管理方便不少。 GitGutter这个小插件是在修改后的文件行号前增加一些标识图片，方便与版本库对比，修改内容一目了然。 Gist创建、管理gist的插件，Gist是GitHub提供的又一强力工具，用Git将用户常用的代码片段在线管理起来。安装此插件后，打开其User-Setting， 增加个人的GitHub访问Token后，即可通过快捷键或Console使用。","tags":[{"name":"工具","slug":"工具","permalink":"//star45.me/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"//star45.me/tags/Sublime-Text-3/"}]},{"title":"Sublime Text 3 《第三章 - 教程》","date":"2017-01-11T10:11:07.000Z","path":"2017/01/11/工具/Sublime-Text-3-《第三章-教程》/","text":"工欲善其事，必先利其器三、sublime Text3 教程 1、修改安装插件的位置 安装完sublime text3，在第一次运行的时候，sublime text3 会在%appdata%目录下生成一个Sublime Text 3的文件夹，用于存放配置文件，以及后面安装的各种插件(所以第一次打开sublime text3时会比较慢) 点击查看原图 要做的第一件事情就是把这个文件移动安装目录，便于设置完后打包。 第一步：安装完sublime text3后，不要直接运行。 找到sublime text3的安装目录，并在该目录下新建 Data 文件夹(注意大小写)。如果已经运行了，请先在地址栏输入 %appdata% 然后删除该目录下的sublime text3文件夹。 完成这一步之后再打开sublime text3所有的配置文件都会被生成在Data文件夹中了 点击查看原图 第二步：安装你需要的插件这就没什么好说的了，还是默认的安装方式。安装后的插件可以在sublime text3安装目录下的 Data/Packages下找到。 第三步：打包sublime text3文件夹打包的文件就可以在其他电脑上直接使用了。 2、注册 生成的密钥 密钥 12345678910111213----- BEGIN LICENSE -----Andrew WeberSingle User LicenseEA7E-855605813A03DD 5E4AD9E6 6C0EEB94 BC99798F942194A6 02396E98 E62C9979 4BB979FE91424C9D A45400BF F6747D88 2FB8807890F5CC94 1CDC92DC 8457107A F151657B1D22E383 A997F016 42397640 33F41CFCE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D5CDB7036 E56DE1C0 EFCC0840 650CD3A6B98FC99C 8FAC73EE D2B95564 DF450523------ END LICENSE ------ 3、汉化4、配置 点击preferences－setting user，个人设置如下： 1234567891011121314151617181920212223242526&#123;//字体大小\"font_size\": 13.0,//字体类型\"font_face\": \"Consolas\",// 设置每一行到顶部，以像素为单位的间距，效果相当于行距\"line_padding_top\": 2,// 设置每一行到底部，以像素为单位的间距，效果相当于行距\"line_padding_bottom\": 2,// html和xml下突出显示光标所在标签的两端，影响HTML、XML、CSS等\"match_tags\": true, // 是否显示代码折叠按钮\"fold_buttons\": true,// 代码提示\"auto_complete\": true,// 默认编码格式\"default_encoding\": \"UTF-8\",// 左边边栏文件夹动画\"tree_animation_enabled\": true,//删除你想要忽略的插件\"ignored_packages\": [ \"Vintage\", \"YUI Compressor\" ]&#125; 5、装插件 插件的安装方法有两个：直接安装和插件管理安装。 直接安装，将下载的安装包解压缩到Packages目录（菜单-&gt;preferences&gt;packages）； Package Control组件安装。用Package Control安装插件的方法： 按下Ctrl+Shift+P调出命令面板，输入install， 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。 有的网络环境可能会不允许访问陌生的网络环境从而设置防火墙，而Sublime Text 貌似无法设置代理，可能就获取不到安装包列表了。 常用插件 Package Control（安装包控制） 打开Sublime Text ，按快捷键 ctrl+` 或者点击 Tools → Command Palette 调出控制台Console；将以下代码复制粘贴进命令行后回车： import urllib2,os;pf=’Package Control.sublime-package’;ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnot os.path.exists(ipp)elseNone;open(os.path.join(ipp,pf),’wb’).write(urllib2.urlopen(‘http://sublime.wbond.net/‘+pf.replace(’ ‘,’%20’)).read()) 重新启动Sublime Text 3，如果在Preferences → Package Settings 中看到 Package Control 这一项，说明安装成功。 Alignment（代码补齐） 下载：https://github.com/wbond/sublime_alignment ColorPicker（调色盘） 下载：https://github.com/weslly/ColorPicker 在编辑CSS样式的时候，ColorPicker可以让sublime text 内置一个调色盘，调好颜色，点击OK就会在光标处生成十六进制颜色代码。 ColorPicker界面见图一 Zen Coding（现已改名为Emmet） 下载：https://github.com/sergeche/emmet-sublime 使用仿CSS选择器的语法来快速开发HTML和CSS，Zen Coding由两个核心组件组成：一个缩写扩展器(缩写为像CSS一样的选择器)和上下文无关的HTML标签对匹配器。 使用ZenCoding编写代码时，需要遵循一定的缩写规则： E元素名（div、p）； E#id带Id的元素（div#content、p#intro、span#error）； E.class带class的的元素（div.header、p.error）,id和class可以连着写，div#content.column E&gt;N子元素（div&gt;p、div#footer&gt;p&gt;span） EN多项元素（ul#nav&gt;li5&gt;a） E+N多项元素 E$*N带序号的元素 SublimeTmpl（自定义新建文件） 下载：https://github.com/kairyou/SublimeTmpl 默认已经添加了html、css、js等常见类型的面板，按ctrl+alt+h/ctrl+alt+c/ctrl+alt+j可新建这 3钟类型的文件，快捷键在这里\\Packages\\SublimeTmpl\\Default (Windows).sublime-keymap, 模板文件在这里\\Packages\\SublimeTmpl\\templates，可修改。 其他插件： Clipboard-history（粘贴板历史记录） 下载：https://github.com/kemayo/sublime-text-2-clipboard-history CSScomb（CSS属性排序） 下载：https://github.com/csscomb/CSScomb-for-Sublime Gits（集成 GitHub） 下载：https://github.com/kemayo/sublime-text-git Hex-to-HSL-Color Hex（颜色模式转HSL颜色模式） 下载：https://github.com/atadams/Hex-to-HSL-Color HtmlTidy（清理与排版你的HTML代码） 下载：https://github.com/welovewordpress/SublimeHtmlTidy JsFormat（javascript格式化） 下载：https://github.com/jdc0589/JsFormat PHPTidy（整理与排版PHP代码） 下载：https://github.com/welovewordpress/SublimePhpTidy SideBarEnhancements（侧边栏增强） 下载：https://github.com/titoBouzout/SideBarEnhancements SublimeLinter（代码错误提示） 下载：https://github.com/SublimeLinter/SublimeLinter/tree/sublime-text-3 SFTP（编辑 FTP 或 SFTP 服务器上的文件） 下载：http://wbond.net/sublime_packages/sftp Tradsim（中文繁字体和简体字转换） 下载：https://github.com/erinata/SublimeTradsim TrailingSpacer（高亮显示多余的空格和Tab） 下载：https://github.com/SublimeText/TrailingSpaces YUI Compressor（压缩JS和CSS文件） 下载：https://github.com/kairyou/SublimeYUICompressor 参考资料 http://www.imjeff.cn/blog/146/ http://blog.csdn.net/idxuanjun/article/details/13292847 http://my.oschina.net/theforever/blog/136554","tags":[{"name":"工具","slug":"工具","permalink":"//star45.me/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"//star45.me/tags/Sublime-Text-3/"}]},{"title":"Sublime Text 3 《第二章 - 介绍》","date":"2017-01-11T10:10:48.000Z","path":"2017/01/11/工具/Sublime-Text-3-《第二章-介绍》/","text":"工欲善其事，必先利其器二、Sublime Text 3 介绍 Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。Sublime Text具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。2012年6月26日推出新版本的Sublime Text 2.0，与之前版本相比主要有较大的改善：支持 Retina 视网膜屏、快速跳到下一个、文本拖放、改善构建系统、CSS 自动完成和高亮设置等。 以上的介绍是引用了百度百科上对Sublime text的解释。 SublimeText是一款非常精巧的文本编辑器，适合编写代码、做笔记、写文章。它用户界面十分整洁，功能非同凡响，性能快得出奇。 这些非常棒的特性 包括： 任意跳转（Goto Anything）、 多重选择（multiple selections）、 指令面板（command palette）、 免打扰模式（distraction free mode）、 分区编辑（split editing）、 快速项目切换（instant project switch）， 你还可以随意地自定义更多功能。 还有，这款编辑器支持Mac、Windows和Linux平台。 SublimeText本身已经非常强大，但是更棒的是有一长串的插件支持它，给它带来更强大的功能。 本文将介绍一些 Sublime Text 3 支持的热门插件（Sublime Text 2 的一些插件在 Sublime Text 3 上不支持）。 以下所讲到的安装包和插件下载地址","tags":[{"name":"工具","slug":"工具","permalink":"//star45.me/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"//star45.me/tags/Sublime-Text-3/"}]},{"title":"Sublime Text 3 《第一章 - 引入》","date":"2017-01-11T10:04:45.000Z","path":"2017/01/11/工具/Sublime-Text-3-《第一章-引入》/","text":"工欲善其事，必先利其器Sublime Text 3 引入 Sublime Text 3 一个如此性感无比的代码编辑器!程序员必备神器!跨平台… Sublime Text 3 是什么 我们为什么要用Sublime Text3 Sublime Text 3 会给我们带来什么 我们带着这些问题，去认识、学习Sublime Text 3 以下所讲到的安装包和插件下载地址","tags":[{"name":"工具","slug":"工具","permalink":"//star45.me/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"//star45.me/tags/Sublime-Text-3/"}]}]