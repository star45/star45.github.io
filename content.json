[{"title":"","date":"2017-05-18T09:58:05.561Z","path":"2017/05/18/springboot/","text":"springboot 整合dubbo使用 xml方式。 用Dubbo做过几个项目了，从来没有碰到过Caused by: Java.lang.ClassCastException这种错误，最后经过反复的测试发现原来是因为依赖了SpringBoot的开发者工具才出现的这一个问题，只要把下面的依赖去掉就解决了这一个问题： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;","tags":[]},{"title":"","date":"2017-05-17T05:43:10.563Z","path":"2017/05/17/java8/SpringBoot/","text":"如果你需要在SpringApplication初始化的时候就做一些事情，使用ApplicationContextInitializer 如果你需要SpringApplication的某个特定阶段做一些事情，使用ApplicationListener（推荐） 如果你需要在beanFactory层面上开发，使用BeanFactoryPostProcessor（推荐） 如果你需要在对某个bean的实例化层面上开发，使用BeanPostProcessor（一般业务上的开发使用InitializingBean或者init-method能够满足）","tags":[]},{"title":"google-guava-functional","date":"2017-04-19T09:18:21.000Z","path":"2017/04/19/google-guava/google-guava4-functional/","text":"","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"//star45.me/tags/Guava/"}]},{"title":"google-guava-caches","date":"2017-04-19T09:18:00.000Z","path":"2017/04/19/google-guava/google-guava3-caches/","text":"","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"//star45.me/tags/Guava/"}]},{"title":"google-guava-collections","date":"2017-04-19T09:17:35.000Z","path":"2017/04/19/google-guava/google-guava2-collections/","text":"GoogleGuava学习 google-guava-collections是什么 我们为什么要用google-guava-collections google-guava-collections会给我们带来什么 我们带着这些问题，去认识、学习google-guava-collections 使用Guava里的Collections，你将受益不菲。它能大量减少你工程里那些样本式的代码 (同时你还能使用它提供的新的速度更快的数据结构！). Google Collection 实现实际开发应用 题外话：前几天开发一个功能的时候，需要一个复杂的数据接口。一个Map里面key-value结构，value的值是使用List。还需要排序、遍历检索等操作，虽然在机器中的运算是比较快的，但是整体的代码比较臃肿。这时候在review同事的代码中发现一个优秀的类库google-guava中的collection。一旦上手发现太爽了。 123456Multimap&lt;Integer, WarrantyBean&gt; warrantyMultimap = ArrayListMultimap.create();for (WarrantyBean warrantyBean : result)&#123; Integer typeKey = warrantyBean.getProductWarrantyType(); warrantyMultimap.put(typeKey,warrantyBean);&#125;Map&lt;Integer,Collection&lt;WarrantyBean&gt;&gt; warrantyMap = warrantyMultimap.asMap(); 这样可以在一次for循环中得到一个Map","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"//star45.me/tags/Guava/"}]},{"title":"google-guava1-basic","date":"2017-04-19T09:13:07.000Z","path":"2017/04/19/google-guava/google-guava1-basic/","text":"","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"//star45.me/tags/Guava/"}]},{"title":"googel-guava-qa-transform","date":"2017-04-19T09:13:07.000Z","path":"2017/04/19/google-guava/googel-guava-qa/","text":"GoogleGuava实际开发Guava Lists.transform dubbo请求序列化问题问题引发今天遇到一个问题，大概是这样的：使用了guava的Lists.transform对一个ArrayList进行转化后，做一个dubbo的请求参数，发生异常。但是使用原生态的ArrayList是没问题的。 在实际工作中我们经常对一个List集合进行转化，常用的就是for循环和forEach。google Guava提供的 transform可以做到更优雅。看例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344//TODO 批量缓存圈子信息private Map&lt;String,String&gt; cacheGomeShopGroupItem(List&lt;GomeStoreItem&gt; gomeStoreItems)&#123; final Map&lt;String,String&gt; shopGroupMap = Maps.newHashMap(); //1、普通for循环 List&lt;String&gt; storeIds = Lists.newArrayList(); for (int i = 0; i &lt;gomeStoreItems.size()&amp;&amp;gomeStoreItems!=null ; i++) &#123; GomeStoreItem gomeStoreItem = gomeStoreItems.get(i); String storeId = null; if (gomeStoreItem != null)&#123; storeId = gomeStoreItem.getGomeStoreId(); &#125; storeIds.add(storeId); &#125; //2、使用transform转化 List&lt;String&gt; storeIds1 = Lists.newArrayList(); storeIds1.addAll(Lists.transform(gomeStoreItems, new Function&lt;GomeStoreItem, String&gt;() &#123; @Nullable @Override public String apply(@Nullable GomeStoreItem gomeStoreItem) &#123; return gomeStoreItem.getGomeStoreId(); &#125; &#125;)); List&lt;GomeShopGroupItem&gt; shopGroupItems = Lists.newArrayList(); try &#123; //正常的dubbo调用 CommonResultEntity&lt;List&lt;ShopGroupInfo&gt;&gt; resuletEntity = opensocialGroupFacade.shopGroupInfo(storeIds); //非正常的dubbo调用 CommonResultEntity&lt;List&lt;ShopGroupInfo&gt;&gt; resuletEntity1 = opensocialGroupFacade.shopGroupInfo(storeIds1); // 业务代码 ...... &#125; catch (Exception e) &#123; logger.error(String.format(\"查询圈子出错：storeIds：%s\",JSON.toJSONString(storeIds))); &#125; return shopGroupMap; &#125; 问题分析以下是使用transform转化的List,使用dubbo调用发生的异常信息： 12Failed to invoke the method shopGroupInfo in the service cn.com.mx.opensocial.group.service.IOpensocialGroupFacade. Tried 3 times of the providers [10.125.198.49:30006] (1/1) from the registry 10.125.198.74:2181 on the consumer 10.144.36.140 using the dubbo version 2.5.5.cat-SNAPSHOT. Last error is: Failed to invoke remote method: shopGroupInfo, provider: dubbo://10.125.198.49:30006/cn.com.mx.opensocial.group.service.IOpensocialGroupFacade?anyhost=true&amp;application=gome-detail-service&amp;check=false&amp;default.accepts=1000&amp;default.check=false&amp;default.timeout=5000&amp;dubbo=2.5.3&amp;heartbeat=100000&amp;interface=cn.com.mx.opensocial.group.service.IOpensocialGroupFacade&amp;methods=shopGroupInfo,strollGroups,checkIsMember&amp;owner=qiantai&amp;pid=4876&amp;providerside=venus-opensocial&amp;revision=1.1&amp;serialization=nativejava&amp;side=consumer&amp;timeout=8000&amp;timestamp=1498030003360&amp;version=1.0.0, cause: Failed to send message Request [id=12, version=2.0.0, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=shopGroupInfo, parameterTypes=[interface java.util.List], arguments=[[1, 6, 10, 20, 30, 31, 40, 10122, 10132, 10138, 10140, 10142, 10145, 10146, 10150, 10159]], attachments=&#123;_catChildMessageId=gome-detail-service-0a90248c-416119-487610019, _catParentMessageId=gome-detail-service-0a90248c-416119-487610018, _rStrategy=null, path=cn.com.mx.opensocial.group.service.IOpensocialGroupFacade, consumerside=gome-detail-service, interface=cn.com.mx.opensocial.group.service.IOpensocialGroupFacade, _catRootMessageId=gome-detail-service-0a90248c-416119-487610018, @null=null, timeout=8000, version=1.0.0&#125;]] to /10.125.198.49:30006, cause: com.gome.item.services.GomeStoreServiceImpl$2 cause: Failed to send message 可以看出发送请求的时候就失败了。那么第一考虑到的就是序列化，因为一次rpc调用肯定需要将参数序列化。 1、ArrayList 实现了 java.io.Serializable接口；2、使用transform生成的TransformingRandomAccessList 并不是ArrayList类型并没有实现序列化接口， 带着问题去查看guava源码：123456789101112/** * Returns a list that applies &#123;@code function&#125; to each element of &#123;@code * fromList&#125;. The returned list is a transformed view of &#123;@code fromList&#125;; * changes to &#123;@code fromList&#125; will be reflected in the returned list and vice * versa. * * &lt;p&gt;Since functions are not reversible, the transform is one-way and new * items cannot be stored in the returned list. The &#123;@code add&#125;, * &#123;@code addAll&#125; and &#123;@code set&#125; methods are unsupported in the returned * list. ........ */ 大概意思：123456/** * 该方法返回一个列表，这个列表中元素是运用方法中传入的功能函数(Function)对原列表中的元素进行处理后的结果, * 它是原列表的一个功能视图，任何对原列表的改变将会体现到视图列表中。因为Function函数是不可逆的， * 所以这样的转换是单向的，并且转换的结果不能存储在返回的列表中。 * 所有对视图列表的添加（add/addAll）、设置（set）等都是不被支持的。 */ 所以说，返回的对象列表是一个视图，其中对它的任何更改都是无效的，并且也不建议对视图对象产生更改，如果需要更改返回的列表，那么需要自己进一步包装，如Lists.newArrayList(retList);如果需要对返回的结果视图进行处理：12List&lt;String&gt; storeIdsArrayList = Lists.newArrayList(storeIds); 这样就可以正常的去做为一个rpc请求的参数了。","tags":[{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"//star45.me/tags/Guava/"}]},{"title":"面试","date":"2017-03-28T08:15:24.000Z","path":"2017/03/28/面试/","text":"一些java面试问题总结 Java基础 Hashtable和HashMap的区别。 抽象类与接口的区别。 final关键字的使用和区别。 异常分类和处理机制。 JDK版本区别。 StringBuilder内部实现机制。 反射机制的使用。 匿名内部类的使用。 泛型的概念和使用。 弱引用和虚引用的概念和使用方式。 开源框架 SpringMVC和Struts2的区别 Spring IOC和AOP的概念以及实现方式 Spring事务的管理 Hibernate与MyBatis的比较 Hibernate延迟加载的机制 JVM虚拟机 GC算法有哪些 垃圾回收器有哪些 如何调优JVM 缓存和NoSQL 缓存的使用场景 缓存命中率的计算 Memcache与Redis的比较 如何实现Redis的分片 MongoDB的特点 分布式 zookeeper的用途 dubbo的用途以及优点 dubbo的实现原理 数据结构和算法 单向链表的逆序排列 双向链表的操作 1亿个整数的倒序输出 找出给定字符串中最长回文（回文：abcdcba，两端对称） 网络编程 Get和Post的区别 Https协议的实现 长连接的管理 Socket的基本方法 数据库 inner join和left join的区别 复杂SQL语句 数据库优化方式 数据库拆分方式 如何保证不同数据结构的数据一致性 安全 什么是XSS攻击，具体如何实现？开放问题：如何保障系统安全？ 设计模式 写出一个设计模式的类图 设计模式的意义是什么 写个单例模式的代码 多线程 如何避免Quartz重复启动任务 线程池满了如何处理额外的请求 同一个对象的连个同步方法能否被两个线程同时调用 华丽丽的分割线 部分答案Java基础 HashMap和Hashtable的区别 HashMap是非线程安全的，Hashtable是线程安全的。 HashMap的键值都可以为null，Hashtable的键值都不可以为null值。 HashMap继承自AbstractMap类，Hashtable继承自Dictionary类。 ps : Properties类继承自Hashtable类。 异常分类和处理机制 分类： 运行时异常（Runtime Exception） 受检查异常（Checked Exception） 运行时异常： 必须继承RuntimeException类， 定义方法时不必声明会抛出运行时异常。 调用方法时不必捕获运行时异常。 受检查异常： 不继承自RumtimeException类 定义方法时需要抛出可能会抛出的Checked Exception 调用方法时需要捕获Checked Exception或者继续向上抛出。 逻辑上： 运行时异常：一般不需要或者不知道如何处理此类异常； 受检验异常：一般需要知道如何处理可能发生的异常情况。 StringBuilder内部实现机制 StringBuilder内部有一个字符数组，代码如下: char[] value; //字符数组 int count; //字符串长度 每一次append操作都是将新的字符串加入到可变长的字符数组中，长度计算方式与ArrayList类似。调用toString()方法时，new一个String对象即可。 123public String toString() &#123; return new String(value, 0, count);// Create a copy, don't share the array&#125; ps: StringBuffer是线程安全的，StringBuilder是非线程安全的。 匿名内部类的使用 匿名内部类是没有名字的类，只在某一处被使用，不会被多处调用，一般是某个父类或接口的特定实现。 强引用、软引用、弱引用和虚引用 强引用: 一般的引用都是强引用，即使OutOfMemory也不会回收这部分被把持的引用内存。 软引用（SoftReference）: 如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被使用。++软引用可以用来实现内存敏感的高速缓存。++ 弱引用（WeakReference）：弱引用的对象拥有更短暂的生命周期。当垃圾回收期发现只有若引用的对象，不论内存空间足够与否，都会回收它。 虚引用（）：虚引用不会决定对象的生命周期，如果一个对象仅持有一个虚引用，那么它随时可能被回收。++虚引用主要用来跟踪对象被垃圾回收器回收的活动。++ 更多关于『强、软、弱和虚引用』参考文章：http://zhangjunhd.blog.51cto…. 开源框架 SpringMVC和Struts2的区别 SpringMVC的方法级别的拦截，Struts2是类级别的拦截； SpringMVC是基于Servlet实现Controller，Struts2是基于Filter实现； SpringMVC性能和安全性高于Struts2； SpringMVC更加组件化和流程化，易于扩展，比如返回JSON通过设置@ResponseBody即可； Struts2更加无耦合，比较纯粹，但是需要更多的自行开发的代码以支持更多功能。 Spring事务的管理 分类：声明式事务、编程式事务 声明式事务：通过统一配置实现事务的统一管理，一般配置TransactionMananger以及相关属性即可。 编程式事务（注解方式）：在需要事务的方法上配置相关的注解（包括事务类型、回滚策略等） 事务类型： PROPAGATION_REQUIRED PROPAGATION_SUPPORTS3.PROPAGATION_MANDATORY PROPAGATION_REQUIRES_NEW PROPAGATION_NOT_SUPPORTED PROPAGATION_NEVER PROPAGATION_NESTED 事务隔离级别 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE Hibernate与MyBatis的比较 Hibernate完全实现对象关系映射（ORM），MyBatis实现的是SQL Mapping MyBatis可以进行更为细致的SQL优化，可以减少查询字段。比Hibernate容易掌握，Hibernate门槛较高。 Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。 Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。 Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。 Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。 JVM虚拟机 GC算法有哪些 引用计数 复制 标记-清除 标记-压缩 分代（新生代、老年代、永久代） 垃圾回收器有哪些 串行回收器：新生代串行回收器、老年代串行回收器 并行回收器：新生代ParNew回收器、新生代ParallelGC回收器、老年代ParallelGC回收器 CMS回收器：（Concurrent Mark Sweep、并发标记清除） G1回收器（1.7以后代替CMS回收器） 如何调优JVM 标准参数： -client -server模式 -Xmn、-Xms、-Xmx 监控：jps、jstat、jinfo、jmap、jhat、jstack… Java 中堆和栈有什么区别？ JVM 中堆和栈属于不同的内存区域，使用目的也不同。 栈常用于保存方法帧和局部变量，而对象总是在堆上分配。 栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。 缓存和NoSQL 缓存命中率的计算 命中缓存次数/(命中缓存次数+未命中缓存次数) = 命中率 Memcache与Redis的区别 memcache把数据存在内存之中，断电后会挂掉；Redis部分数据持久化在硬盘上，断电不会丢失。 memcache存的是key-value对，redis支持更多的数据结构和数据类型 memcache可以使用一致性hash做分布式，redis可以做主从同步 redis单线程，只使用1个cpu 如何实现Redis的分片 使用一致性哈希对数据进行映射 实现方式：客户端分片（每个客户端对应一个分片）、代理协助分片、查询路由分片； 使用redis集群，如codis（豌豆荚，依赖zookeeper）； 分布式 zookeeper的用途 zookeeper作为分布式应用协调系统，已经用到很多分布式项目中。可以用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项等管理工作。 zookeeper的主要操作分一下几种： 创建节点 读取节点数据 更新节点数据 删除节点 监控节点变化 应用场景： 统一命名服务，使用create自动创建节点编号； 配置管理，多个节点的共享配置，当配置发生变化时，可利用zookeeper让使用这些配置的节点获得通知，进行重新加载等操作。如dubbo服务。 集群管理：集群选举主节点，资源定位。 共享锁 负载均衡 应用项目：dubbo服务集群、redis集群、Hadoop集群等 dubbo的用途以及优点 Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。 数据结构和算法 将单项链表逆序排列 将单向链表逆序输出，方法有三种： 遍历链表，将每个节点的内容存入一个数组中，然后逆序输出数组(最简单的做法) 使用栈来逆序输出 直接将链表（指针）逆序然后输出 单向链表详细信息参考文章：http://blog.csdn.net/jianyuer… 海量数据操作 十道面试题与十个海量数据处理方法总结 http://blog.csdn.net/v_july_v/article/details/6279498","tags":[{"name":"Java","slug":"Java","permalink":"//star45.me/tags/Java/"}]},{"title":"22.贡献","date":"2017-03-17T04:11:08.000Z","path":"2017/03/17/hexo/22-contributing/","text":"开发我们非常欢迎您加入 Hexo 的开发，这份文件将帮助您了解开发流程。 开始之前请遵守以下准则： 遵守 Google JavaScript 代码风格。 使用 2 个空格缩排。 不要把逗号放在最前面。 工作流程 Fork hexojs/hexo 把库（repository）复制到电脑上，并安装所依赖的插件。 1234$ git clone https://github.com/&lt;username&gt;/hexo.git$ cd hexo$ npm install$ git submodule update --init 新增一个功能分支。 1$ git checkout -b new_feature 开始开发。 推送（push）分支。 1$ git push origin new_feature 建立一个新的合并申请（pull request）并描述变动。 注意事项 不要修改 package.json 的版本号。 只有在测试通过的情况下您的合并申请才会被批准，在提交前别忘了进行测试。 1$ npm test 更新文档Hexo 文档开放源代码，您可以在 hexojs/site 找到源代码。 工作流程 Fork hexojs/site 把库（repository）复制到电脑上，并安装所依赖的插件。 123$ git clone https://github.com/&lt;username&gt;/site.git$ cd site$ npm install 开始编辑文件，您可以通过服务器预览变动。 1$ hexo server 推送（push）分支。 建立一个新的合并申请（pull request）并描述变动。 翻译 在 source 资料夹中建立一个新的语言资料夹（全小写）。 把 source 资料夹中相关的文件（Markdown 和模板文件）复制到新的语言资料夹中。 在 source/_data/language.yml 中新增语言。 将 en.yml 复制到 themes/navy/languages中并命名为语言名称（全小写）。 反馈问题当您在使用 Hexo 时遇到问题，您可以尝试在 问题解答 中寻找解答，或是在 GitHub 或 Google Group 上提问。如果你没有找答案，请在 Github 报告它。 在 调试模式 中重现问题。 运行 hexo version 并检查版本信息。 把调试信息和版本信息都贴到 GitHub。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"21.问题解答","date":"2017-03-17T03:11:08.000Z","path":"2017/03/17/hexo/21-troubleshooting/","text":"在使用 Hexo 时，您可能会遇到一些问题，下列的常见问题解答可能会对您有所帮助。如果您在这里找不道解答，可以在 GitHub 或 Google Group 上提问。 YAML 解析错误12JS-YAML: incomplete explicit mapping pair; a key node is missed at line 18, column 29: last_updated: Last updated: %s 如果 YAML 字符串中包含冒号（:）的话，请加上引号。 12JS-YAML: bad indentation of a mapping entry at line 18, column 31: last_updated:&quot;Last updated: %s&quot; 请确认您使用空格进行缩进（Soft tab），并确认冒号后有加上一个空格。 您可参阅 YAML 规范 以取得更多信息。 EMFILE 错误1Error: EMFILE, too many open files 虽然 Node.js 有非阻塞 I/O，同步 I/O 的数量仍被系统所限制，在生成大量静态文件的时候，您可能会碰到 EMFILE 错误，您可以尝试提高同步 I/O 的限制数量来解决此问题。 1$ ulimit -n 10000 （这一命令只对Linux系统有效） Git 部署问题1fatal: &apos;username.github.io&apos; does not appear to be a git repository 请确认您已经在电脑上 配置 git，或改用 HTTPS 库（repository）地址。 服务器问题1Error: listen EADDRINUSE 您可能同时开启两个 Hexo 服务器，或者有其他应用程序正在占用相同的端口，请尝试修改 port 参数，或是在启动 Hexo 服务器时加上 -p 选项。 1$ hexo server -p 5000 插件安装问题1npm ERR! node-waf configure build 当您尝试安装以 C/C++ 或其他非 JavaScript 语言所编写的插件时，可能会遇到此类问题，请确认您已经在电脑上安装相对应的编译器。 DTrace 错误 （Mac OS X）123&#123; [Error: Cannot find module &apos;./build/Release/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/default/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125;&#123; [Error: Cannot find module &apos;./build/Debug/DTraceProviderBindings&apos;] code: &apos;MODULE_NOT_FOUND&apos; &#125; DTrace 安装可能有错误 , 使用下列命令:1$ npm install hexo --no-optional 参考 #1326 在 Jade 或 Swig 遍历资料Hexo 使用 Warehouse 存储资料，它不是一般数组所以必须先进行类型转型才能遍历。 12&#123;% for post in site.posts.toArray() %&#125;&#123;% endfor %&#125; 资料没有更新有时资料可能没有被更新，或是生成的文件与修改前的相同，您可以尝试清除缓存并再执行一次。 1$ hexo clean 泄露（Escape）内容Hexo 使用 Nunjucks 来解析文章（旧版本使用 Swig，两者语法类似），内容若包含 {{ }} 或 {% %} 可能导致解析错误，您可以用 raw 标签包裹来避免潜在问题发生。 123&#123;% raw %&#125;Hello &#123;&#123; sensitive &#125;&#125;&#123;% endraw %&#125; ENOSPC 错误 （Linux）运行 $ hexo server 命令有时会返回这样的错误：1Error: watch ENOSPC ... 它可以用过运行 $ npm dedupe 来解决，如果不起作用的话，可以尝试在 Linux 终端中运行下列命令：1$ echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p 这将会提高你能监视的文件数量。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"20.插件","date":"2017-03-16T08:11:08.000Z","path":"2017/03/16/hexo/20-plugins/","text":"Hexo 有强大的插件系统，使您能轻松扩展功能而不用修改核心模块的源码。在 Hexo 中有两种形式的插件： 脚本（Scripts）如果您的代码很简单，建议您编写脚本，您只需要把 JavaScript 文件放到 scripts 文件夹，在启动时就会自动载入。 插件（Packages）如果您的代码较复杂，或是您想要发布到 NPM 上，建议您编写插件。首先，在 node_modules 文件夹中建立文件夹，文件夹名称开头必须为 hexo-，如此一来 Hexo 才会在启动时载入否则 Hexo 将会忽略它。 文件夹内至少要包含 2 个文件：一个是主程序，另一个是 package.json，描述插件的用途和所依赖的插件。 123.├── index.js└── package.json package.json 中至少要包含 name, version, main 属性，例如： package.json12345&#123; \"name\": \"hexo-my-plugin\", \"version\": \"0.0.1\", \"main\": \"index\"&#125; 工具您可以使用 Hexo 提供的官方工具插件来加速开发： hexo-fs：文件 IO hexo-util：工具程式 hexo-i18n：本地化（i18n） hexo-pagination：生成分页资料 发布当您完成插件后，可以考虑将它发布到 插件列表，让更多人能够使用您的插件。发布插件的步骤和 更新文件 非常类似。 Fork hexojs/site 把库（repository）复制到电脑上，并安装所依赖的插件。 123$ git clone https://github.com/&lt;username&gt;/site.git$ cd site$ npm install 编辑 source/_data/plugins.yml，在档案中新增您的插件，例如： 1234567- name: hexo-server description: Server module for Hexo. link: https://github.com/hexojs/hexo-server tags: - official - server - console 推送（push）分支。 建立一个新的合并申请（pull request）并描述改动。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"19.国际化（i18n）","date":"2017-03-16T07:11:08.000Z","path":"2017/03/16/hexo/19-internationalization/","text":"若要让您的网站以不同语言呈现，您可使用国际化（internationalization）功能。请先在 _config.yml 中调整 language 设定，这代表的是预设语言，您也可设定多个语言来调整预设语言的顺位。12345language: zh-twlanguage: - zh-tw- en 语言文件语言文件可以使用 YAML 或 JSON 编写，并放在主题文件夹中的 languages 文件夹。您可以在语言文件中使用 printf 格式。 模板在模板中，透过 __ 或 _p 辅助函数，即可取得翻译后的字符串，前者用于一般使用；而后者用于复数字符串。例如： en.yml1234567index: title: Home add: Add video: zero: No videos one: One video other: %d videos 12345&lt;%= __('index.title') %&gt;// Home&lt;%= _p('index.video', 3) %&gt;// 3 videos 路径您可在 front-matter 中指定该页面的语言，也可在 _config.yml 中修改 i18n_dir 设定，让 Hexo 自动侦测。 1i18n_dir: :lang i18n_dir 的预设值是 :lang，也就是说 Hexo 会捕获网址中的第一段以检测语言，举例来说： 123/index.html =&gt; en/archives/index.html =&gt; en/zh-tw/index.html =&gt; zh-tw 捕获到的字符串唯有在语言文件存在的情况下，才会被当作是语言，因此例二 /archives/index.html 中的 archives 就不被当成是语言。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"18.辅助函数（Helpers）","date":"2017-03-16T06:11:08.000Z","path":"2017/03/16/hexo/18-helpers/","text":"辅助函数帮助您在模版中快速插入内容。辅助函数不能在源文件中使用。 网址url_for在路径前加上根路径，从 Hexo 2.7 开始您应该使用此函数而不是 config.root + path。 1&lt;%- url_for(path) %&gt; relative_url取得与 from 相对的 to 路径。 1&lt;%- relative_url(from, to) %&gt; gravatar插入 Gravatar 图片。如果你不指定 options 参数，将会应用默认参数。否则，你可以将其设置为一个数字，这个数字将会作为 Gravatar 的大小参数。最后，如果你设置它一个对象，它将会被转换为 Gravatar 的一个查询字符串参数。 1&lt;%- gravatar(email, [options]); 示例： 12345678&lt;%- gravatar('a@abc.com') %&gt;// http://www.gravatar.com/avatar/b9b00e66c6b8a70f88c73cb6bdb06787&lt;%- gravatar('a@abc.com', 40) %&gt;// http://www.gravatar.com/avatar/b9b00e66c6b8a70f88c73cb6bdb06787?s=40&lt;%- gravatar('a@abc.com' &#123;s: 40, d: 'http://example.com/image.png'&#125;) %&gt;// http://www.gravatar.com/avatar/b9b00e66c6b8a70f88c73cb6bdb06787?s=40&amp;d=http%3A%2F%2Fexample.com%2Fimage.png HTML 标签css载入 CSS 文件。path 可以是数组或字符串，如果 path 开头不是 / 或任何协议，则会自动加上根路径；如果后面没有加上 .css 扩展名的话，也会自动加上。 1&lt;%- css(path, ...) %&gt; 示例： 123456&lt;%- css('style.css') %&gt;// &lt;link rel=\"stylesheet\" href=\"/style.css\" type=\"text/css\"&gt;&lt;%- css(['style.css', 'screen.css']) %&gt;// &lt;link rel=\"stylesheet\" href=\"/style.css\" type=\"text/css\"&gt;// &lt;link rel=\"stylesheet\" href=\"/screen.css\" type=\"text/css\"&gt; js载入 JavaScript 文件。path 可以是数组或字符串，如果 path 开头不是 / 或任何协议，则会自动加上根路径；如果后面没有加上 .js 扩展名的话，也会自动加上。 1&lt;%- js(path, ...) %&gt; 示例： 123456&lt;%- js('script.js') %&gt;// &lt;script type=\"text/javascript\" src=\"/script.js\"&gt;&lt;/script&gt;&lt;%- js(['script.js', 'gallery.js']) %&gt;// &lt;script type=\"text/javascript\" src=\"/script.js\"&gt;&lt;/script&gt;// &lt;script type=\"text/javascript\" src=\"/gallery.js\"&gt;&lt;/script&gt; link_to插入链接。 1&lt;%- link_to(path, [text], [options]) %&gt; 参数 描述 默认值 external 在新视窗打开链接 false class Class 名称 id ID 示例： 12345678&lt;%- link_to('http://www.google.com') %&gt;// &lt;a href=\"http://www.google.com\" title=\"http://www.google.com\"&gt;http://www.google.com&lt;/a&gt;&lt;%- link_to('http://www.google.com', 'Google') %&gt;// &lt;a href=\"http://www.google.com\" title=\"Google\"&gt;Google&lt;/a&gt;&lt;%- link_to('http://www.google.com', 'Google', &#123;external: true&#125;) %&gt;// &lt;a href=\"http://www.google.com\" title=\"Google\" target=\"_blank\" rel=\"external\"&gt;Google&lt;/a&gt; mail_to插入电子邮箱链接。 1&lt;%- mail_to(path, [text], [options]) %&gt; 参数 描述 class Class 名称 id ID subject 邮件主题 cc 抄送（CC） bcc 密送（BCC） body 邮件内容 示例： 12345&lt;%- mail_to('a@abc.com') %&gt;// &lt;a href=\"mailto:a@abc.com\" title=\"a@abc.com\"&gt;a@abc.com&lt;/a&gt;&lt;%- mail_to('a@abc.com', 'Email') %&gt;// &lt;a href=\"mailto:a@abc.com\" title=\"Email\"&gt;Email&lt;/a&gt; image_tag插入图片。 1&lt;%- image_tag(path, [options]) %&gt; 参数 描述 alt 图片的替代文字 class Class 名称 id ID width 图片宽度 height 图片高度 favicon_tag插入 favicon。 1&lt;%- favicon_tag(path) %&gt; feed_tag插入 feed 链接。 1&lt;%- feed_tag(path, [options]) %&gt; 参数 描述 默认值 title Feed 标题 type Feed 类型 atom 条件函数is_current检查 path 是否符合目前页面的网址。开启 strict 选项启用严格比对。 1&lt;%- is_current(path, [strict]) %&gt; is_home检查目前是否为首页。 1&lt;%- is_home() %&gt; is_post检查目前是否为文章。 1&lt;%- is_post() %&gt; is_archive检查目前是否为存档页面。 1&lt;%- is_archive() %&gt; is_year检查目前是否为年度归档页面。 1&lt;%- is_year() %&gt; is_month检查目前是否为月度归档页面。 1&lt;%- is_month() %&gt; is_category检查目前是否为分类归档页面。如果给定一个字符串作为参数，将会检查目前是否为指定分类。 12&lt;%- is_category() %&gt;&lt;%- is_category('hobby') %&gt; is_tag检查目前是否为标签归档页面。如果给定一个字符串作为参数，将会检查目前是否为指定标签。 12&lt;%- is_tag() %&gt;&lt;%- is_tag('hobby') %&gt; 字符串处理trim清除字符串开头和结尾的空格。 1&lt;%- trim(string) %&gt; strip_html清除字符串中的 HTML 标签。 1&lt;%- strip_html(string) %&gt; 示例： 12&lt;%- strip_html('It's not &lt;b&gt;important&lt;/b&gt; anymore!') %&gt;// It's not important anymore! titlecase把字符串转换为正确的 Title case。 1&lt;%- titlecase(string) %&gt; 示例： 12&lt;%- titlecase('this is an apple') %&gt;# This is an Apple markdown使用 Markdown 解析字符串。 1&lt;%- markdown(str) %&gt; 示例： 12&lt;%- markdown('make me **strong**') %&gt;// make me &lt;strong&gt;strong&lt;/strong&gt; render解析字符串。 1&lt;%- render(str, engine, [options]) %&gt; word_wrap使每行的字符串长度不超过 length。length 预设为 80。 1&lt;%- word_wrap(str, [length]) %&gt; 示例： 12&lt;%- word_wrap('Once upon a time', 8) %&gt;// Once upon\\n a time truncate移除超过 length 长度的字符串。 1&lt;%- truncate(text, length) %&gt; 示例： 12345678&lt;%- truncate('Once upon a time in a world far far away', &#123;length: 17&#125;) %&gt;// Once upon a ti...&lt;%- truncate('Once upon a time in a world far far away', &#123;length: 17, separator: ' '&#125;) %&gt;// Once upon a...&lt;%- truncate('And they found that many people were sleeping better.', &#123;length: 25, omission: '... (continued)'&#125;) %&gt;// And they f... (continued) 模板partial载入其他模板文件，您可在 locals 设定区域变量。 1&lt;%- partial(layout, [locals], [options]) %&gt; 参数 描述 默认值 cache 缓存（使用 Fragment cache） false only 限制局部变量。在模板中只能使用 locals 中设定的变量。 false fragment_cache局部缓存。它储存局部内容，下次使用时就能直接使用缓存。 1&lt;%- fragment_cache(id, fn); 示例： 123&lt;%- fragment_cache('header', function()&#123; return '&lt;header&gt;&lt;/header&gt;';&#125;) %&gt; 日期与时间date插入格式化的日期。date 可以是 UNIX 时间、ISO 字符串、Date 对象或 Moment.js 对象。format 默认为 date_format 配置信息。 1&lt;%- date(date, [format]) %&gt; 示例： 12345&lt;%- date(Date.now()) %&gt;// 2013-01-01&lt;%- date(Date.now(), 'YYYY/M/D') %&gt;// Jan 1 2013 date_xml插入 XML 格式的日期。date 可以是 UNIX 时间、ISO 字符串、Date 对象或 Moment.js 对象。 1&lt;%- date_xml(date) %&gt; 示例： 12&lt;%- date_xml(Date.now()) %&gt;// 2013-01-01T00:00:00.000Z time插入格式化的时间。date 可以是 UNIX 时间、ISO 字符串、Date 对象或 Moment.js 对象。format 默认为 time_format 配置信息。 1&lt;%- time(date, [format]) %&gt; 示例： 12345&lt;%- time(Date.now()) %&gt;// 13:05:12&lt;%- time(Date.now(), 'h:mm:ss a') %&gt;// 1:05:12 pm full_date插入格式化的日期和时间。date 可以是 UNIX 时间、ISO 字符串、Date 对象或 Moment.js 对象。format 默认为 date_format + time_format。 1&lt;%- full_date(date, [format]) %&gt; 示例： 12345&lt;%- full_date(new Date()) %&gt;// Jan 1, 2013 0:00:00&lt;%- full_date(new Date(), 'dddd, MMMM Do YYYY, h:mm:ss a') %&gt;// Tuesday, January 1st 2013, 12:00:00 am momentMoment.js 函数库。 列表list_categories插入分类列表。 1&lt;%- list_categories([options]) %&gt; 参数 描述 默认值 orderby 分类排列方式 name order 分类排列顺序。1, asc 升序；-1, desc 降序。 1 show_count 显示每个分类的文章总数 true style 分类列表的显示方式。使用 list 以无序列表（unordered list）方式显示。 list separator 分类间的分隔符号。只有在 style 不是 list 时有用。 , depth 要显示的分类层级。0 显示所有层级的分类；-1 和 0 很类似，但是显示不分层级；1 只显示第一层的分类。 0 class 分类列表的 class 名称。 category transform 改变分类名称显示方法的函数 list_tags插入标签列表。 1&lt;%- list_tags([options]) %&gt; 选项 描述 预设值 orderby 标签排列方式 name order 标签排列顺序。1, asc 升序；-1, desc 降序。 1 show_count 显示每个标签的文章总数 true style 标签列表的显示方式。使用 list 以无序列表（unordered list）方式显示。 list separator 标签间的分隔符号。只有在 style 不是 list 时有用。 , class 标签列表的 class 名称。 tag transform 改变标签名称显示方法的函数 amount 要显示的标签数量（0 = 无限制） 0 list_archives插入归档列表。 1&lt;%- list_archives([options]) %&gt; 参数 描述 默认值 type 类型。此设定可为 yearly 或 monthly。 monthly order 排列顺序。1, asc 升序；-1, desc 降序。 1 show_count 显示每个归档的文章总数 true format 日期格式 MMMM YYYY style 归档列表的显示方式。使用 list 以无序列表（unordered list）方式显示。 list separator 归档间的分隔符号。只有在 style 不是 list 时有用。 , class 归档列表的 class 名称。 archive transform 改变归档名称显示方法的函数 list_posts插入文章列表。 1&lt;%- list_posts([options]) %&gt; 参数 描述 默认值 orderby 文章排列方式 date order 文章排列顺序。1, asc 升序；-1, desc 降序。 -1 style 文章列表的显示方式。使用 list 以无序列表（unordered list）方式显示。 list separator 文章间的分隔符号。只有在 style 不是 list 时有用。 , class 文章列表的 class 名称。 post amount 要显示的文章数量（0 = 无限制） 6 transform 改变文章名称显示方法的函数 tagcloud插入标签云。 1&lt;%- tagcloud([tags], [options]) %&gt; 参数 描述 默认值 min_font 最小字体尺寸 10 max_font 最大字体尺寸 20 unit 字体尺寸的单位 px amount 标签总量 40 orderby 标签排列方式 name order 标签排列顺序。1, sac 升序；-1, desc 降序 1 color 使用颜色 false start_color 开始的颜色。您可使用十六进位值（#b700ff），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。 end_color 结束的颜色。您可使用十六进位值（#b700ff），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。 其他paginator插入分页链接。 1&lt;%- paginator(options) %&gt; 参数 描述 默认值 base 基础网址 / format 网址格式 page/%d/ total 分页总数 1 current 目前页数 0 prev_text 上一页链接的文字。仅在 prev_next 设定开启时才有用。 Prev next_text 下一页链接的文字。仅在 prev_next 设定开启时才有用。 Next space 空白文字 &hellip; prev_next 显示上一页和下一页的链接 true end_size 显示于两侧的页数 1 mid_size 显示于中间的页数 2 show_all 显示所有页数。如果开启此参数的话，end_size 和 mid_size 就没用了。 false search_form插入 Google 搜索框。 1&lt;%- search_form(options) %&gt; 参数 描述 默认值 class 表单的 class name search-form text 搜索提示文字 Search button 显示搜索按钮。此参数可为布尔值（boolean）或字符串，当设定是字符串的时候，即为搜索按钮的文字。 false number_format格式化数字。 1&lt;%- number_format(number, [options]) %&gt; 参数 描述 默认值 precision 数字精度。此选项可为 false 或非负整数。 false delimiter 千位数分隔符号 , separator 整数和小数之间的分隔符号 . 示例： 1234567891011121314&lt;%- number_format(12345.67, &#123;precision: 1&#125;) %&gt;// 12,345.68&lt;%- number_format(12345.67, &#123;precision: 4&#125;) %&gt;// 12,345.6700&lt;%- number_format(12345.67, &#123;precision: 0&#125;) %&gt;// 12,345&lt;%- number_format(12345.67, &#123;delimiter: ''&#125;) %&gt;// 12345.67&lt;%- number_format(12345.67, &#123;separator: '/'&#125;) %&gt;// 12,345/67 open_graph插入 open graph 资源。 1&lt;%- open_graph([options]) %&gt; 参数 描述 默认值 title 页面标题 (og:title) page.title type 页面类型 (og:type) blog url 页面网址 (og:url) url image 页面图片 (og:image) 内容中的图片 site_name 网站名称 (og:site_name) config.title description 页面描述 (og:desription) 内容摘要或前 200 字 twitter_card Twitter 卡片类型 (twitter:card) summary twitter_id Twitter ID (twitter:creator) twitter_site Twitter 网站 (twitter:site) google_plus Google+ 个人资料链接 fb_admins Facebook 管理者 ID fb_app_id Facebook 应用程序 ID toc解析内容中的标题标签 (h1~h6) 并插入目录。 1&lt;%- toc(str, [options]) %&gt; 参数 描述 默认值 class Class 名称 toc list_number 显示编号 true 示例： 1&lt;%- toc(page.content) %&gt;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"17.变量","date":"2017-03-16T04:11:08.000Z","path":"2017/03/16/hexo/17-variables/","text":"使用hexo变量 全局变量 变量 描述 site 网站变量 page 针对该页面的内容以及 front-matter 所设定的变量。 config 网站配置 theme 主题配置。继承自网站配置。 _ (单下划线) Lodash 函数库 path 当前页面的路径（不含根路径） url 当前页面的完整网址 env 环境变量 网站变量 变量 描述 site.posts 所有文章 site.pages 所有分页 site.categories 所有分类 site.tags 所有标签 页面变量页面（page） 变量 描述 page.title 页面标题 page.date 页面建立日期（Moment.js 对象） page.updated 页面更新日期（Moment.js 对象） page.comments 留言是否开启 page.layout 布局名称 page.content 页面的完整内容 page.excerpt 页面摘要 page.more 除了页面摘要的其余内容 page.source 页面原始路径 page.full_source 页面的完整原始路径 page.path 页面网址（不含根路径）。我们通常在主题中使用 url_for(page.path)。 page.permalink 页面的完整网址 page.prev 上一个页面。如果此为第一个页面则为 null。 page.next 下一个页面。如果此为最后一个页面则为 null。 page.raw 文章的原始内容 page.photos 文章的照片（用于相簿） page.link 文章的外部链接（用于链接文章） 文章 (post): 和 page 布局类似，但是添加了下列变量。 Variable Description page.published 如果该文章已发布则为True page.categories 该文章的所有分类 page.tags 该文章的所有标签 首页（index） 变量 描述 page.per_page 每页显示的文章数量 page.total 总文章数 page.current 目前页数 page.current_url 目前分页的网址 page.posts 本页文章 page.prev 上一页的页数。如果此页是第一页的话则为 0。 page.prev_link 上一页的网址。如果此页是第一页的话则为 &#39;&#39;。 page.next 下一页的页数。如果此页是最后一页的话则为 0。 page.next_link 下一页的网址。如果此页是最后一页的话则为 &#39;&#39;。 page.path 当前页面的路径（不含根目录）。我们通常在主题中使用 url_for(page.path)。 归档 (archive)：与 index 布局相同，但新增以下变量。 变量 描述 page.archive 等于 true page.year 年份归档 (4位) page.month 月份归档 (没有前导零的2位数) 分类 (category)：与 index 布局相同，但新增以下变量。 变量 描述 page.category 分类名称 标签 (tag)：与 index 布局相同，但新增以下变量。 变量 描述 page.tag 标签名称","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"16.模板","date":"2017-03-16T03:11:08.000Z","path":"2017/03/16/hexo/16-templates/","text":"模板决定了网站内容的呈现方式，每个主题至少都应包含一个 index 模板，以下是各页面相对应的模板名称：模板 | 用途 | 回调— | — | —index | 首页 |post | 文章 | indexpage | 分页 | indexarchive | 归档 | indexcategory | 分类归档 | archivetag | 标签归档 | archive 布局（Layout）如果页面结构类似，例如两个模板都有页首（Header）和页脚（Footer），您可考虑通过「布局」让两个模板共享相同的结构。一个布局文件必须要能显示 body 变量的内容，如此一来模板的内容才会被显示，举例来说： index.ejs1index layout.ejs1234&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt;&lt;%- body %&gt;&lt;/body&gt;&lt;/html&gt; 生成： 1234&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt;index&lt;/body&gt;&lt;/html&gt; 每个模板都默认使用 layout 布局，您可在 front-matter 指定其他布局，或是设为 false 来关闭布局功能，您甚至可在布局中再使用其他布局来建立嵌套布局。 局部模版（Partial）局部模板让您在不同模板之间共享相同的组件，例如页首（Header）、页脚（Footer）或侧边栏（Sidebar）等，可利用局部模板功能分割为个别文件，让维护更加便利。举例来说： partial/header.ejs1&lt;h1 id=\"logo\"&gt;&lt;%= config.title %&gt;&lt;/h1&gt; index.ejs12&lt;%- partial('partial/header') %&gt;&lt;div id=\"content\"&gt;Home page&lt;/div&gt; 生成： 12&lt;h1 id=\"logo\"&gt;My Site&lt;/h1&gt;&lt;div id=\"content\"&gt;Home page&lt;/div&gt; 局部变量您可以在局部模板中指定局部变量并使用。 partial/header.ejs1&lt;h1 id=\"logo\"&gt;&lt;%= title&gt;&lt;/h1&gt; index.ejs12&lt;%- partial('partial/header', &#123;title: 'Hello World'&#125;) %&gt;&lt;div id=\"content\"&gt;Home page&lt;/div&gt; 生成： 12&lt;h1 id=\"logo\"&gt;Hello World&lt;/h1&gt;&lt;div id=\"content\"&gt;Home page&lt;/div&gt; 优化如果您的主题太过于复杂，或是需要生成的文件量太过于庞大，可能会大幅降低性能，除了简化主题外，您可以考虑 Hexo 2.7 新增的局部缓存（Fragment Caching） 功能。 本功能借鉴于 Ruby on Rails，它储存局部内容，下次便能直接使用缓存内容，可以减少文件夹查询并使生成速度更快。 它可用于页首、页脚、侧边栏等文件不常变动的位置，举例来说： 123&lt;%- fragment_cache('header', function()&#123; return '&lt;header&gt;&lt;/header&gt;';&#125;); 如果您使用局部模板的话，可以更简单： 1&lt;%- partial('header', &#123;&#125;, &#123;cache: true&#125;); 但是，如果您开启了 relative_link 参数的话，请勿使用局部缓存功能，因为相对链接在每个页面可能不同。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"15.主题","date":"2017-03-15T08:11:08.000Z","path":"2017/03/15/hexo/15-themes/","text":"创建 Hexo 主题非常容易，您只要在 themes 文件夹内，新增一个任意名称的文件夹，并修改 _config.yml 内的 theme 设定，即可切换主题。一个主题可能会有以下的结构： 123456.├── _config.yml├── languages├── layout├── scripts└── source _config.yml主题的配置文件。修改时会自动更新，无需重启服务器。 languages语言文件夹。请参见 国际化 (i18n)。 layout布局文件夹。用于存放主题的模板文件，决定了网站内容的呈现方式，Hexo 内建 Swig 模板引擎，您可以另外安装插件来获得 EJS、Haml 或 Jade 支持，Hexo 根据模板文件的扩展名来决定所使用的模板引擎，例如： 12layout.ejs - 使用 EJSlayout.swig - 使用 Swig 您可参考 模板 以获得更多信息。 scripts脚本文件夹。在启动时，Hexo 会载入此文件夹内的 JavaScript 文件，请参见 插件 以获得更多信息。 source资源文件夹，除了模板以外的 Asset，例如 CSS、JavaScript 文件等，都应该放在这个文件夹中。文件或文件夹开头名称为 _（下划线线）或隐藏的文件会被忽略。 如果文件可以被渲染的话，会经过解析然后储存到 public 文件夹，否则会直接拷贝到 public 文件夹。 发布当您完成主题后，可以考虑将它发布到 主题列表，让更多人能够使用您的主题。在发布前建议先进行 主题单元测试，确保每一项功能都能正常使用。发布主题的步骤和 更新文档 非常类似。 Fork hexojs/site 把库（repository）复制到电脑上，并安装所依赖的插件。 123$ git clone https://github.com/&lt;username&gt;/site.git$ cd site$ npm install 编辑 source/_data/themes.yml，在文件中新增您的主题，例如： 12345678910- name: landscape description: A brand new default theme for Hexo. link: https://github.com/hexojs/hexo-theme-landscape preview: http://hexo.io/hexo-theme-landscape tags: - official - responsive - widget - two_column - one_column 在 source/themes/screenshots 新增同名的截图档案，图片必须为 800x500 的 PNG 文件。 推送（push）分支。 建立一个新的合并申请（pull request）并描述改动。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"14.永久链接（Permalinks）","date":"2017-03-15T07:11:51.000Z","path":"2017/03/15/hexo/14-permalinks/","text":"您可以在 _config.yml 配置中调整网站的永久链接或者在每篇文章的 Front-matter 中指定。 变量除了下列变量外，您还可使用 Front-matter 中的所有属性。 变量 描述 :year 文章的发表年份（4 位数） :month 文章的发表月份（2 位数） :i_month 文章的发表月份（去掉开头的零） :day 文章的发表日期 (2 位数) :i_day 文章的发表日期（去掉开头的零） :title 文件名称 :id 文章 ID :category 分类。如果文章没有分类，则是 default_category 配置信息。 您可在 permalink_defaults 参数下调整永久链接中各变量的默认值： 12permalink_defaults: lang: en 示例假设 source/_posts 文件夹中有个 hello-world.md，包含以下内容： 12345title: Hello Worlddate: 2013-07-14 17:01:34categories:- foo- bar 参数 结果 :year/:month/:day/:title/ 2013/07/14/hello-world :year-:month-:day-:title.html 2013-07-14-hello-world.html :category/:title foo/bar/hello-world 多语种支持若要建立一个多语种的网站，您可修改 new_post_name 和 permalink 参数，如下： 12new_post_name: :lang/:title.mdpermalink: :lang/:title/ 当您建立新文章时，文章会被储存到： 12$ hexo new \"Hello World\" --lang tw# =&gt; source/_posts/tw/Hello-World.md 而网址会是： 1http://localhost:4000/tw/hello-world/","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"13.部署","date":"2017-03-15T06:11:51.000Z","path":"2017/03/15/hexo/13-deployment/","text":"Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。1$ hexo deploy 在开始之前，您必须先在 _config.yml 中修改参数，一个正确的部署配置中至少要有 type 参数，例如： 12deploy: type: git 您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。 12345deploy:- type: git repo:- type: heroku repo: 缩进YAML依靠缩进来确定元素间的从属关系。因此，请确保每个deployer的缩进长度相同，并且使用空格缩进。 Git安装 hexo-deployer-git。 1$ npm install hexo-deployer-git --save 修改配置。 12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] 参数 描述 repo 库（Repository）地址 branch 分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。 message 自定义提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}) Heroku安装 hexo-deployer-heroku。 1$ npm install hexo-deployer-heroku --save 修改配置。 1234deploy: type: heroku repo: &lt;repository url&gt; message: [message] 参数 描述 repo Heroku 库（Repository）地址 message 自定提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}) Rsync安装 hexo-deployer-rsync。 1$ npm install hexo-deployer-rsync --save 修改配置。 123456789deploy: type: rsync host: &lt;host&gt; user: &lt;user&gt; root: &lt;root&gt; port: [port] delete: [true|false] verbose: [true|false] ignore_errors: [true|false] 参数 描述 默认值 host 远程主机的地址 user 使用者名称 root 远程主机的根目录 port 端口 22 delete 删除远程主机上的旧文件 true verbose 显示调试信息 true ignore_errors 忽略错误 false rsync部署模块的工作方式需要注意的是，要求您提供的实际上是一个能通过SSH登陆远程主机的Linux用户。Hexo会自动处理关于rsync使用的一切操作。因此，您需要在远程主机上为您的Hexo站点建立一个用户，并允许其通过SSH登陆。不过，这里的port，的确是指rsync监听的端口，请确保防火墙打开了该端口。 OpenShift安装 hexo-deployer-openshift。 1$ npm install hexo-deployer-openshift --save 修改配置。 1234deploy: type: openshift repo: &lt;repository url&gt; message: [message] 参数 描述 repo OpenShift 库（Repository）地址 message 自定提交信息 (默认为 Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}) FTPSync安装 hexo-deployer-ftpsync。 1$ npm install hexo-deployer-ftpsync --save 修改配置。 12345678910deploy: type: ftpsync host: &lt;host&gt; user: &lt;user&gt; pass: &lt;password&gt; remote: [remote] port: [port] ignore: [ignore] connections: [connections] verbose: [true|false] 参数 描述 默认值 host 远程主机的地址 user 使用者名称 pass 密码 remote 远程主机的根目录 / port 端口 21 ignore 忽略的文件或目录 connections 使用的连接数 1 verbose 显示调试信息 false FTP部署可能出现的问题您可能需要预先通过其他方式将所有文件上传到远程主机中。否则初次使用ftpsync插件就可能出现报错。另外，由于FTP协议的特征，它每传送一个文件就需要一次握手，相对速度较慢。 其他方法Hexo 生成的所有文件都放在 public 文件夹中，您可以将它们复制到您喜欢的地方。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"12.生成文件","date":"2017-03-15T04:11:51.000Z","path":"2017/03/15/hexo/12-generating/","text":"使用hexo生产文件使用 Hexo 生成静态文件快速而且简单。 1$ hexo generate 监视文件变动Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。 1$ hexo generate --watch 完成后部署您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。 12$ hexo generate --deploy$ hexo deploy --generate 简写上面两个命令可以简写为$ hexo g -d$ hexo d -g","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"11.服务器","date":"2017-03-15T03:11:08.000Z","path":"2017/03/15/hexo/11-server/","text":"hexo服务器操作 hexo-serverHexo 3.0 把服务器独立成了个别模块，您必须先安装 hexo-server 才能使用。 1$ npm install hexo-server --save 安装完成后，输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。 1$ hexo server 如果您想要更改端口，或是在执行时遇到了 EADDRINUSE 错误，可以在执行时使用 -p 选项指定其他端口，如下： 1$ hexo server -p 5000 静态模式在静态模式下，服务器只处理 public 文件夹内的文件，而不会处理文件变动，在执行时，您应该先自行执行 hexo generate，此模式通常用于生产环境（production mode）下。 1$ hexo server -s 自定义 IP服务器默认运行在 0.0.0.0，您可以覆盖默认的 IP 设置，如下： 1$ hexo server -i 192.168.1.1 指定这个参数后，您就只能通过该IP才能访问站点。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的127.0.0.1外，通常还有一个192.168.*.*的局域网IP，如果像上面那样使用-i参数，就不能用127.0.0.1来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为-i参数的值，那么就无法通过公网来访问站点。 PowPow 是一个 Mac 系统上的零配置 Rack 服务器，它也可以作为一个简单易用的静态文件服务器来使用。 安装1$ curl get.pow.cx | sh 设置在 ~/.pow 文件夹建立链接（symlink）。 12$ cd ~/.pow$ ln -s /path/to/myapp 您的网站将会在 http://myapp.dev 下运行，网址根据链接名称而定。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"10.数据文件","date":"2017-03-14T08:11:08.000Z","path":"2017/03/14/hexo/10-data-files/","text":"有时您可能需要在主题中使用某些资料，而这些资料并不在文章内，并且是需要重复使用的，那么您可以考虑使用 Hexo 3.0 新增的「数据文件」功能。此功能会载入 source/_data 内的 YAML 或 JSON 文件，如此一来您便能在网站中复用这些文件了。举例来说，在 source/_data 文件夹中新建 menu.yml 文件： 123Home: /Gallery: /gallery/Archives: /archives/ 您就能在模板中使用这些资料： 123&#123;% for link in site.data.menu %&#125; &lt;a href=\"&#123;&#123; link &#125;&#125;\"&gt;&#123;&#123; loop.key &#125;&#125;&lt;/a&gt;&#123;% endfor %&#125;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"9.资源文件夹","date":"2017-03-14T07:11:08.000Z","path":"2017/03/14/hexo/9-asset-folders/","text":"资源（Asset）代表 source 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 source/images 文件夹中。然后通过类似于 ![](/images/image.jpg) 的方法访问它们。 文章资源文件夹对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 config.yml 文件中的 post_asset_folder 选项设为 true 来打开。 _config.yml1post_asset_folder: true 当资源文件管理功能打开后，Hexo将会在你每一次通过 hexo new [layout] &lt;title&gt; 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。 相对路径引用的标签插件通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; 比如说：当你打开文章资源文件夹功能后，你把一个 example.jpg 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 ![](/example.jpg) ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作） 正确的引用图片方式是使用下列的标签插件而不是 markdown ： 1&#123;% asset_img example.jpg This is an example image %&#125; 通过这种方式，图片将会同时出现在文章和主页以及归档页中。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"8.标签插件（Tag Plugins）","date":"2017-03-14T06:11:08.000Z","path":"2017/03/14/hexo/8-tag-plugins/","text":"标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。 引用块在文章中插入引言，可包含作者、来源和标题。 别号： quote 123&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;content&#123;% endblockquote %&#125; 样例没有提供参数，则只输出普通的 blockquote 123&#123;% blockquote %&#125;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.&#123;% endblockquote %&#125; Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. 引用书上的句子 123&#123;% blockquote David Levithan, Wide Awake %&#125;Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.&#123;% endblockquote %&#125; Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. David LevithanWide Awake 引用 Twitter 123&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;NEW: DevDocs now comes with syntax highlighting. http://devdocs.io&#123;% endblockquote %&#125; NEW: DevDocs now comes with syntax highlighting. http://devdocs.io @DevDocstwitter.com/devdocs/status/356095192085962752 引用网络上的文章 123&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;Every interaction is both precious and an opportunity to delight.&#123;% endblockquote %&#125; Every interaction is both precious and an opportunity to delight. Seth GodinWelcome to Island Marketing 代码块在文章中插入代码。 别名： code 123&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 样例普通的代码块 123&#123;% codeblock %&#125;alert('Hello World!');&#123;% endcodeblock %&#125; 1alert('Hello World!'); 指定语言 123&#123;% codeblock lang:objc %&#125;[rectangle setX: 10 y: 10 width: 20 height: 20];&#123;% endcodeblock %&#125; 1[rectangle setX: 10 y: 10 width: 20 height: 20]; 附加说明 123&#123;% codeblock Array.map %&#125;array.map(callback[, thisArg])&#123;% endcodeblock %&#125; Array.map1array.map(callback[, thisArg]) 附加说明和网址 1234&#123;% codeblock _.compact http://underscorejs.org/#compact Underscore.js %&#125;_.compact([0, 1, false, 2, '', 3]);=&gt; [1, 2, 3]&#123;% endcodeblock %&#125; _.compactUnderscore.js12_.compact([0, 1, false, 2, '', 3]);=&gt; [1, 2, 3] 反引号代码块另一种形式的代码块，不同的是它使用三个反引号来包裹。 &#96`` [language] [title] [url] [link text] code snippet &#96;`` Pull Quote在文章中插入 Pull quote。 123&#123;% pullquote [class] %&#125;content&#123;% endpullquote %&#125; jsFiddle在文章中嵌入 jsFiddle。 1&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125; Gist在文章中嵌入 Gist。 1&#123;% gist gist_id [filename] %&#125; iframe在文章中插入 iframe。 1&#123;% iframe url [width] [height] %&#125; Image在文章中插入指定大小的图片。 1&#123;% img [class names] /path/to/image [width] [height] [title text [alt text]] %&#125; Link在文章中插入链接，并自动给外部链接添加 target=&quot;_blank&quot; 属性。 1&#123;% link text url [external] [title] %&#125; Include Code插入 source 文件夹内的代码文件。 1&#123;% include_code [title] [lang:language] path/to/file %&#125; Youtube在文章中插入 Youtube 视频。 1&#123;% youtube video_id %&#125; Vimeo在文章中插入 Vimeo 视频。 1&#123;% vimeo video_id %&#125; 引用文章引用其他文章的链接。 12&#123;% post_path slug %&#125;&#123;% post_link slug [title] %&#125; 引用资源引用文章的资源。 123&#123;% asset_path slug %&#125;&#123;% asset_img slug [title] %&#125;&#123;% asset_link slug [title] %&#125; Raw如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。 123&#123;% raw %&#125;content&#123;% endraw %&#125;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"7.Front-matter","date":"2017-03-14T04:11:08.000Z","path":"2017/03/14/hexo/7-front-matter/","text":"Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：123title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 分类和标签只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。 12345categories:- Diarytags:- PS3- Games 分类方法的分歧如果您有过使用WordPress的经验，就很容易误解Hexo的分类方式。WordPress支持对一篇文章设置多个分类，而且这些分类可以是同级的，也可以是父子分类。但是Hexo不支持指定多个同级分类。下面的指定方法：categories: Diary Life会使分类Life成为Diary的子分类，而不是并列分类。因此，有必要为您的文章选择尽可能准确的分类。 JSON Front-matter除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 --- 代换成 ;;; 即可。 123\"title\": \"Hello World\",\"date\": \"2013/7/13 20:46:25\";;;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"6.写作","date":"2017-03-14T03:11:08.000Z","path":"2017/03/14/hexo/6-writing/","text":"您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 布局 路径 post source/_posts page source draft source/_drafts 不要处理我的文章如果你不想你的文章被处理，你可以将 Front-Matter 中的layout: 设为 false 。 文件名称Hexo 默认以标题做为文件名称，但您可编辑 new_post_name 参数来改变默认的文件名称，举例来说，设为 :year-:month-:day-:title.md 可让您更方便的通过日期来管理文章。 变量 描述 :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7 草稿刚刚提到了 Hexo 的一种特殊布局：draft，这种布局在建立时会被保存到 source/_drafts 文件夹，您可通过 publish 命令将草稿移动到 source/_posts 文件夹，该命令的使用方式与 new 十分类似，您也可在命令中指定 layout 来指定布局。 1$ hexo publish [layout] &lt;title&gt; 草稿默认不会显示在页面中，您可在执行时加上 --draft 参数，或是把 render_drafts 参数设为 true 来预览草稿。 模版（Scaffold）在新建文章时，Hexo 会根据 scaffolds 文件夹内相对应的文件来建立文件，例如： 1$ hexo new photo \"My Gallery\" 在执行这行指令时，Hexo 会尝试在 scaffolds 文件夹中寻找 photo.md，并根据其内容建立文章，以下是您可以在模版中使用的变量： 变量 描述 layout 布局 title 标题 date 文件建立日期","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"5.迁移","date":"2017-03-13T08:11:08.000Z","path":"2017/03/13/hexo/5-migration/","text":"使用hexo迁移一些文章 RSS首先，安装 hexo-migrator-rss 插件。 1$ npm install hexo-migrator-rss --save 插件安装完成后，执行下列命令，从 RSS 迁移所有文章。source 可以是文件路径或网址。 1$ hexo migrate rss &lt;source&gt; Jekyll把 _posts 文件夹内的所有文件复制到 source/_posts 文件夹，并在 _config.yml 中修改 new_post_name 参数。 1new_post_name: :year-:month-:day-:title.md Octopress把 Octopress source/_posts 文件夹内的所有文件转移到 Hexo 的 source/_posts 文件夹，并修改 _config.yml 中的 new_post_name 参数。 1new_post_name: :year-:month-:day-:title.md WordPress首先，安装 hexo-migrator-wordpress 插件。 1$ npm install hexo-migrator-wordpress --save 在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考WP支持页面）。 插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。 1$ hexo migrate wordpress &lt;source&gt; 注意这个插件并不能完美地实现WordPress-&gt;Hexo的数据转换，尤其是在处理WordPress的分类方面存在问题（见Front-matter中的分类与标签）。因此，建议您在迁移完成后，手工审阅所有生成的markdown文件，检查其中是否有错误。对于文章数量较大的WordPress站点，这项工作可能要花很长的时间。 Joomla首先，安装 hexo-migrator-joomla 插件。 1$ npm install hexo-migrator-joomla --save 使用 J2XML 组件导出 Joomla 文章。插件安装完成后，执行下列命令来迁移所有文章。source 可以是 Joomla 导出的文件路径或网址。 1$ hexo migrate joomla &lt;source&gt;","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"4.概指令","date":"2017-03-13T07:18:08.000Z","path":"2017/03/13/hexo/4-commands/","text":"一些hexo命令 init1$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new1$ hexo new [layout] &lt;title&gt; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate1$ hexo generate 生成静态文件。 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 该命令可以简写为1$ hexo g publish1$ hexo publish [layout] &lt;filename&gt; 发表草稿。 server1$ hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 deploy1$ hexo deploy 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 该命令可以简写为：1$ hexo d render1$ hexo render &lt;file1&gt; [file2] ... 渲染文件。 参数 描述 -o, --output 设置输出路径 migrate1$ hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1$ hexo list &lt;type&gt; 列出网站资料。 version1$ hexo version 显示 Hexo 版本。 选项安全模式1$ hexo --safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式1$ hexo --debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式1$ hexo --silent 隐藏终端信息。 自定义配置文件的路径1$ hexo --config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿1$ hexo --draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD1$ hexo --cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"3.配置","date":"2017-03-13T06:11:08.000Z","path":"2017/03/13/hexo/3-configuration/","text":"您可以在 _config.yml 中修改大部份的配置。 网站 参数 描述 title 网站标题 subtitle 网站副标题 description 网站描述 author 您的名字 language 网站使用的语言 timezone 网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。 其中，description主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。author参数用于主题显示文章的作者。 网址 参数 描述 默认值 url 网址 root 网站根目录 permalink 文章的 永久链接 格式 :year/:month/:day/:title/ permalink_defaults 永久链接中各部分的默认值 网站存放在子目录如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。 目录 参数 描述 默认值 source_dir 资源文件夹，这个文件夹用来存放内容。 source public_dir 公共文件夹，这个文件夹用于存放生成的站点文件。 public tag_dir 标签文件夹 tags archive_dir 归档文件夹 archives category_dir 分类文件夹 categories code_dir Include code 文件夹 downloads/code i18n_dir 国际化（i18n）文件夹 :lang skip_render 跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。 提示如果您刚刚开始接触Hexo，通常没有必要修改这一部分的值。 文章 参数 描述 默认值 new_post_name 新文章的文件名称 :title.md default_layout 预设布局 post auto_spacing 在中文和英文之间加入空格 false titlecase 把标题转换为 title case false external_link 在新标签中打开链接 true filename_case 把文件名称转换为 (1) 小写或 (2) 大写 0 render_drafts 显示草稿 false post_asset_folder 启动 Asset 文件夹 false relative_link 把链接改为与根目录的相对位址 false future 显示未来的文章 true highlight 代码块的设置 相对地址默认情况下，Hexo生成的超链接都是绝对地址。例如，如果您的网站域名为example.com,您有一篇文章名为hello，那么绝对链接可能像这样：http://example.com/hello.html，它是绝对于域名的。相对链接像这样：/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。 分类 &amp; 标签 参数 描述 默认值 default_category 默认分类 uncategorized category_map 分类别名 tag_map 标签别名 日期 / 时间格式Hexo 使用 Moment.js 来解析和显示时间。 参数 描述 默认值 date_format 日期格式 YYYY-MM-DD time_format 时间格式 H:mm:ss 分页 参数 描述 默认值 per_page 每页显示的文章量 (0 = 关闭分页功能) 10 pagination_dir 分页目录 page 扩展 参数 描述 theme 当前主题名称。值为false时禁用主题 deploy 部署部分的设置","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"2.建站","date":"2017-03-13T04:11:08.000Z","path":"2017/03/13/hexo/2-setup/","text":"使用hexo建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes _config.yml网站的 配置 信息，您可以在此配置大部分的参数。 package.json应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装，您可以自由移除。 package.json12345678910111213141516171819&#123; \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": &#123; \"version\": \"\" &#125;, \"dependencies\": &#123; \"hexo\": \"^3.0.0\", \"hexo-generator-archive\": \"^0.1.0\", \"hexo-generator-category\": \"^0.1.0\", \"hexo-generator-index\": \"^0.1.0\", \"hexo-generator-tag\": \"^0.1.0\", \"hexo-renderer-ejs\": \"^0.1.0\", \"hexo-renderer-stylus\": \"^0.2.0\", \"hexo-renderer-marked\": \"^0.2.4\", \"hexo-server\": \"^0.1.2\" &#125;&#125; scaffolds模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。 source资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。 themes主题 文件夹。Hexo 会根据主题来生成静态页面。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"Spring系列1-Filter","date":"2017-03-13T04:02:45.000Z","path":"2017/03/13/Spring系列1-Filter/","text":"SpringFramework学习 Spring提供的Filter 是什么 我们为什么要用Spring提供的Filter Spring提供的Filter 会给我们带来什么 我们带着这些问题，去认识、学习Spring提供的Filter过滤器 Spring Framework 是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，以Apache许可证形式发布，也有.NET平台上的移植版本。该框架基于 Expert One-on-One Java EE Design and Development（ISBN 0-7645-4385-7）一书中的代码，最初由Rod Johnson和Juergen Hoeller等开发。Spring Framework提供了一个简易的开发方式，这种开发方式，将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类。 Spring提供的filter有如下这些，list filter: AbstractRequestLoggingFilter CharacterEncodingFilter CommonsRequestLoggingFilter CompositeFilter DelegatingFilterProxy GenericFilterBean HiddenHttpMethodFilter HttpPutFormContentFilter Log4jNestedDiagnosticContextFilter OncePerRequestFilter RequestContextFilter ServletContextRequestLoggingFilter ShallowEtagHeaderFilter 一、CharacterEncodingFilterCharacterEncodingFilter主要用于处理请求中的乱码问题。 这个类的继承关系如下： CharacterEncodingFilter的部分源码： 123456789101112131415161718public class CharacterEncodingFilter extends OncePerRequestFilter &#123; private String encoding; private boolean forceEncoding = false; @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response); &#125;&#125; forceEncoding 为 true 为设置response的编码，并不会对request参数造成影响。 使用例子： 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","tags":[{"name":"Spring","slug":"Spring","permalink":"//star45.me/tags/Spring/"},{"name":"Framework","slug":"Framework","permalink":"//star45.me/tags/Framework/"}]},{"title":"Spring系列1-Filter","date":"2017-03-13T04:02:45.000Z","path":"2017/03/13/Spring系列2-Ioc/","text":"SpringFramework学习 Spring Ioc 是什么 我们为什么要用Spring Ioc Spring Ioc 会给我们带来什么 我们带着这些问题，去认识、学习Spring Ioc ## Spring Framework 是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，以Apache许可证形式发布，也有.NET平台上的移植版本。该框架基于 Expert One-on-One Java EE Design and Development（ISBN 0-7645-4385-7）一书中的代码，最初由Rod Johnson和Juergen Hoeller等开发。Spring Framework提供了一个简易的开发方式，这种开发方式，将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类。 1. IoC理论的背景耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品spring。 2. 什么是控制反转(IoC)IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。 我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。 3. IOC的别名：依赖注入(DI)依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。 4. IOC为我们带来了什么好处 组件之间低耦合或者无耦合带来的好处。 5. IOC容器的技术剖析IOC中最基本的技术就是“反射(Reflection)”编程 ##待更新##","tags":[{"name":"framework","slug":"framework","permalink":"//star45.me/tags/framework/"},{"name":"Spring","slug":"Spring","permalink":"//star45.me/tags/Spring/"}]},{"title":"1.概述","date":"2017-03-13T02:11:08.000Z","path":"2017/03/13/hexo/1-index/","text":"对hexo一些描述 欢迎使用 Hexo，本文档将帮助您快速上手。如果您在使用过程中遇到问题，请查看 问题解答 中的解答，或者在 GitHub、Google Group 上提问。 什么是 Hexo？Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装安装 Hexo 只需几分钟时间，若您在安装过程中遇到问题或无法找到解决方式，请提交问题，我会尽力解决您的问题。 安装前提安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： Node.js Git 如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。 1$ npm install -g hexo-cli 如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。 Mac 用户您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。 安装 Git Windows：下载并安装 git. Mac：使用 Homebrew, MacPorts ：brew install git;或下载 安装程序 安装。 Linux (Ubuntu, Debian)：sudo apt-get install git-core Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core Windows 用户由于众所周知的原因，从上面的链接下载git for windows最好挂上一个代理，否则下载速度十分缓慢。也可以参考这个页面，收录了存储于百度云的下载地址。 安装 Node.js安装 Node.js 的最佳方式是使用 nvm。 cURL: 1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh Wget: 1$ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。 1$ nvm install stable 或者您也可以下载 安装程序 来安装。 Windows 用户对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。另外，您也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，您可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，您可以考虑始终使用Git Bash来进行操作。 安装 Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 1$ npm install -g hexo-cli","tags":[{"name":"Hexo","slug":"Hexo","permalink":"//star45.me/tags/Hexo/"},{"name":"建站","slug":"建站","permalink":"//star45.me/tags/建站/"}]},{"title":"github维护","date":"2017-01-11T10:12:17.000Z","path":"2017/01/11/github维护/","text":"关于github的学习管理 github的一些操作 一、建立项目二、导入项目三、使用git维护四、编写readme.md1、使用MarkDown2、个性的图标http://shields.io/ 项目介绍 Star 项目版本 项目构建 项目覆盖 项目许可 项目下载","tags":[{"name":"Github","slug":"Github","permalink":"//star45.me/tags/Github/"}]},{"title":"Linux下shell脚本执行jar文件","date":"2017-01-11T10:11:51.000Z","path":"2017/01/11/Linux下shell脚本执行jar文件/","text":"使用shell脚本执行一些命令 以下是具体的命令脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/bin/bash#description: 启动重启server服务 #端口号，根据此端口号确定PID PORT=9997 #启动命令所在目录 HOME='/usr/etc/server/java/server' #查询出监听了PORT端口TCP协议的程序 pid=`netstat -anp|grep $PORT|awk '&#123;printf $7&#125;'|cut -d/ -f1` start()&#123; if [ -n \"$pid\" ]; then echo \"server already start,pid:$pid\" return 0 fi #进入命令所在目录 cd $HOME nohup java -jar $HOME/pserver9997.jar &gt; $HOME/server.log 2&gt;&amp;1 &amp; #启动聊天服务器 把日志输出到HOME目录的server.log文件中 echo \"start at port:$PORT\" &#125; stop()&#123; if [ -z \"$pid\" ]; then echo \"not find program on port:$PORT\" return 0 fi #结束程序，使用讯号2，如果不行可以尝试讯号9强制结束 kill -9 $pid rm -rf $pid echo \"kill program use signal 2,pid:$pid\" &#125; status()&#123; if [ -z \"$pid\" ]; then echo \"not find program on port:$PORT\" else echo \"program is running,pid:$pid\" fi &#125; case $1 in start) start ;; stop) stop ;; restart) $0 stop sleep 2 $0 start ;; status) status ;; *) echo \"Usage: &#123;start|stop|status&#125;\" ;; esac exit 0","tags":[{"name":"Linux","slug":"Linux","permalink":"//star45.me/tags/Linux/"}]},{"title":"Sublime Text 3 《第四章 - 插件》","date":"2017-01-11T10:11:25.000Z","path":"2017/01/11/Sublime-Text-3-《第四章-插件》/","text":"工欲善其事，必先利其器四、Sublime Text 3 插件详解 插件列表: SideBarEnhancements : 左侧菜单栏 Anaconda : Python集成插件 ConvertToUTF8 : 非utf8文本自动转换 BetterCoffeeScript : Coffee支持 emmet : ZenCoding Markdown preview : markdown预览 MarkdownEditing : markdown高亮 Gutter Color : 显示颜色，需要先运行brew install ImageMagick terminal : 直接打开终端 Git : 直接使用Git命令(当然要先有git) 各种格式化的插件就按照自己的需求选装吧 安装完成后，一个绝对不会卡的轻便IDE就完成了！ 1、SublimeTmpl Sublime Text 新建文件的模版插件: SublimeTmpl写了个sublime的模版插件, 项目主页: https://github.com/kairyou/SublimeTmpl 这样就可以新建文件时使用模版的内容了, 目前添加了 1* html js css php python ruby 六种模版. 不需新建空白文件, 再从其他文件复制内容过来了. 已增加对Sublime Text3的支持. 使用: 11. ST菜单, File-New File (SublimeTmpl), 选择列表里的相应菜单, 可直接使用模版新建文件. 命令, cmd+shift+p, 输入: “tmpl:”, 可以找到创建文件的菜单列表. 快捷键, 默认快捷键见下面. 可以自己修改, 方法见”设置”部分. 默认快捷键: | 快捷键 | 目标文件 || — | — || ctrl+alt+h | html || ctrl+alt+j | javascript || ctrl+alt+c | css || ctrl+alt+p | php || ctrl+alt+r | ruby || ctrl+alt++shift+p | python | 安装: 11\\. 方法1\\. 通过 Package Control Package Control / Install Package, 搜索”SublimeTmpl” 或 “tmpl”, 安装.已经通过Package Control审核 12\\. 方法2\\. Github 打开项目主页, Git clone到ST的Packages文件夹(\\Data\\Packages), 或直接把ZIP格式的下载下来解压到Packages文件夹(文件夹名称必须为:SublimeTmpl). 设置: 菜单: Preferences / Packages Settings / SublimeTmpl, 可以编辑菜单/快捷键/新语法等等. 如果你想贡献自己的package, 可以参考我这篇文章的介绍:http://www.fantxi.com/blog/archives/how-to-submit-a-sublime-package/ 新增特性: 11. 用户自定义模板 (Thanks @Xu Cheng Github) 自定义模板路径: “Data\\Packages\\User\\SublimeTmpl\\templates” 目录, 会优先使用.默认模版路径: “Data\\Packages\\SublimeTmpl\\templates” 目录.用自己自定义的模板: 推荐把默认模版目录的*.tmpl文件 复制到 自定义模板路径, 再去修改. 12. 模板支持 $&#123;date&#125; 变量 settings - user里面可以修改${date}默认的输出格式(“%Y-%m-%d %H:%M:%S”), 比如改成: “date_format” : “%Y-%m-%d” 13\\. 模板支持自定义 attr settings - user里添加: 12345\"attr\": &#123;\"author\": \"your name\" ,\"email\": \"mail@yours.com\",\"link\": \"http://yours.com\",\"hello\": \"word\" }`就能在模板中使用 author{email} link{hello} 变量Thanks @vfasky (Blog) 另外, 关于新增语言的附加说明 11\\. 新增SublimeTmpl里面没有的语言 首先请看: Packages Settings / SublimeTmpl / Settings - Default 的默认语法设置.如果要新增语法, 请选择: SublimeTmpl / Settings - User, 内容格式参考Settings - Default的内容, 比如新增两个语言test和yours: ` { &quot;test&quot;: {&quot;syntax&quot;: &quot;Packages/test/test.tmLanguage&quot;}, &quot;yours&quot;: {&quot;syntax&quot;: &quot;Packages/Yours/Yours.tmLanguage&quot;} } ` ` 新增开始菜单: 可以在SublimeTmpl / Settings - Menu里, 参照其他语法增加test和yours. 新增快捷键: 可以编辑:SublimeTmpl / Key Bindings User( 格式参考: SublimeTmpl / Key Bindings Default) 新增Sublime的语言 1234567这个我也没新建过, 可以去Package Control或者github上面找个其他人添加的新语言, 参考参考.如果没找到别人写好的, 可以参考如下网址, 自己做:1. [官方文档][1], 利用AAAPackageDev这个插件制作2. [textmate的doc][2], 和sublime大部分是相同的3. [语法][3], 可以和自己新建的对比4. [详解][4]，很全面的教程 四、快捷键（只针对目前的软件） ctrl+alt+f格式化js代码 —— jsFormat tabhtml提示 ——- emmet 随心所欲的跳转Cmd+P之所以被叫做 Goto Anything 并不是虚名： 1* `Command+P` 可以快速跳转到当前项目中的任意文件，可进行关键词匹配。 Command+P后@(或是Command+R)可以快速列出/跳转到某个函数（很爽的是markdown 当中是匹配到标题，而且还是带缩进的！）。 Command+P后#可以在当前文件中进行搜索。 Command+P后 : (或是Ctrl+G)加上数字可以跳转到相应的行。而更酷的是你可以用Command+P加上一些关键词跳转到某个文件同时加上 @ 来列出/跳转到目标文件中的某个函数，或是同时加上 # 来在目标文件中进行搜索，或是同时加上 : 和数字来跳转到目标文件中相应的行。 以下是个人总结不完全的快捷键总汇，祝愿各位顺利解放自己的鼠标。 选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和Gtrl+Z一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类 Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+：打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式 五、开发环境1、java开发环境2、Python开发环境 SublimeREPL，REPL就是read-evaluation-print-loop，解释型语言编译运行的过程）。装了SublimeREPL插件后也支持了编辑器上直接的编译运行和交互，但还是有一些不满的地方。SublimeREPL提供的功能当中有两个我比较常用的是运行Python交互环境和直接运行当前文件，而python自带的IDLE跟人性化的做法是把这两者结合起来，所以我想实现的是对当前的文件运行python的交互环境。 SublimeREPL 允许你在编辑界面直接运行 Python 解释器。我倾向于在单独的终端窗口用 bpython 来运行，但有时 SublimeREPL 是很有帮助的。 Pylinter 这个插件提供了目前我所见到的最好的 pylint 编辑器整合。它自动检查 .py 文件，无论其何时被保存，并且会直接在编辑界面显示 pylint 违规。它还有一个快捷方式来禁用局部的 pylint 检查，通过插入一个 #pylint: 禁用注释。这个插件对于我确实非常有用。 Anaconda绝对是换到Sublime Text 3后最令我兴奋的插件，没有之一。在Sublime Text 2的时代，为配置一个好用的python开发环境， 我们需要分别安装All Autocomplete,SublimeREPL,Pylinter和PEP8等诸多插件。 Geek就是让一切变得更简单，该插件作者就为了简便，把这些功能集中起来了。 Anaconda把PyFlakes, pep8 和 McCabe以插件的方式集成起来。安装Anaconda后，通过配置即可完成一个良好的Python开发环境。 3、markdown环境 markdown支持 http://www.ihunter.me/sublime-text-3%E4%B8%AD%E9%85%8D%E7%BD%AEmarkdown.html 4、git环境版本库是软件开发中不可缺少的工具，该插件把Git常用命令加入了Command Palette，让开发人员进行代码管理方便不少。 GitGutter这个小插件是在修改后的文件行号前增加一些标识图片，方便与版本库对比，修改内容一目了然。 Gist创建、管理gist的插件，Gist是GitHub提供的又一强力工具，用Git将用户常用的代码片段在线管理起来。安装此插件后，打开其User-Setting， 增加个人的GitHub访问Token后，即可通过快捷键或Console使用。","tags":[{"name":"工具","slug":"工具","permalink":"//star45.me/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"//star45.me/tags/Sublime-Text-3/"}]},{"title":"Sublime Text 3 《第三章 - 教程》","date":"2017-01-11T10:11:07.000Z","path":"2017/01/11/Sublime-Text-3-《第三章-教程》/","text":"工欲善其事，必先利其器三、sublime Text3 教程 1、修改安装插件的位置 安装完sublime text3，在第一次运行的时候，sublime text3 会在%appdata%目录下生成一个Sublime Text 3的文件夹，用于存放配置文件，以及后面安装的各种插件(所以第一次打开sublime text3时会比较慢) 点击查看原图 要做的第一件事情就是把这个文件移动安装目录，便于设置完后打包。 第一步：安装完sublime text3后，不要直接运行。 找到sublime text3的安装目录，并在该目录下新建 Data 文件夹(注意大小写)。如果已经运行了，请先在地址栏输入 %appdata% 然后删除该目录下的sublime text3文件夹。 完成这一步之后再打开sublime text3所有的配置文件都会被生成在Data文件夹中了 点击查看原图 第二步：安装你需要的插件这就没什么好说的了，还是默认的安装方式。安装后的插件可以在sublime text3安装目录下的 Data/Packages下找到。 第三步：打包sublime text3文件夹打包的文件就可以在其他电脑上直接使用了。 2、注册 生成的密钥 密钥 12345678910111213----- BEGIN LICENSE -----Andrew WeberSingle User LicenseEA7E-855605813A03DD 5E4AD9E6 6C0EEB94 BC99798F942194A6 02396E98 E62C9979 4BB979FE91424C9D A45400BF F6747D88 2FB8807890F5CC94 1CDC92DC 8457107A F151657B1D22E383 A997F016 42397640 33F41CFCE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D5CDB7036 E56DE1C0 EFCC0840 650CD3A6B98FC99C 8FAC73EE D2B95564 DF450523------ END LICENSE ------ 3、汉化4、配置 点击preferences－setting user，个人设置如下： 1234567891011121314151617181920212223242526&#123;//字体大小\"font_size\": 13.0,//字体类型\"font_face\": \"Consolas\",// 设置每一行到顶部，以像素为单位的间距，效果相当于行距\"line_padding_top\": 2,// 设置每一行到底部，以像素为单位的间距，效果相当于行距\"line_padding_bottom\": 2,// html和xml下突出显示光标所在标签的两端，影响HTML、XML、CSS等\"match_tags\": true, // 是否显示代码折叠按钮\"fold_buttons\": true,// 代码提示\"auto_complete\": true,// 默认编码格式\"default_encoding\": \"UTF-8\",// 左边边栏文件夹动画\"tree_animation_enabled\": true,//删除你想要忽略的插件\"ignored_packages\": [ \"Vintage\", \"YUI Compressor\" ]&#125; 5、装插件 插件的安装方法有两个：直接安装和插件管理安装。 直接安装，将下载的安装包解压缩到Packages目录（菜单-&gt;preferences&gt;packages）； Package Control组件安装。用Package Control安装插件的方法： 按下Ctrl+Shift+P调出命令面板，输入install， 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。 有的网络环境可能会不允许访问陌生的网络环境从而设置防火墙，而Sublime Text 貌似无法设置代理，可能就获取不到安装包列表了。 常用插件 Package Control（安装包控制） 打开Sublime Text ，按快捷键 ctrl+` 或者点击 Tools → Command Palette 调出控制台Console；将以下代码复制粘贴进命令行后回车： import urllib2,os;pf=’Package Control.sublime-package’;ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnot os.path.exists(ipp)elseNone;open(os.path.join(ipp,pf),’wb’).write(urllib2.urlopen(‘http://sublime.wbond.net/‘+pf.replace(’ ‘,’%20’)).read()) 重新启动Sublime Text 3，如果在Preferences → Package Settings 中看到 Package Control 这一项，说明安装成功。 Alignment（代码补齐） 下载：https://github.com/wbond/sublime_alignment ColorPicker（调色盘） 下载：https://github.com/weslly/ColorPicker 在编辑CSS样式的时候，ColorPicker可以让sublime text 内置一个调色盘，调好颜色，点击OK就会在光标处生成十六进制颜色代码。 ColorPicker界面见图一 Zen Coding（现已改名为Emmet） 下载：https://github.com/sergeche/emmet-sublime 使用仿CSS选择器的语法来快速开发HTML和CSS，Zen Coding由两个核心组件组成：一个缩写扩展器(缩写为像CSS一样的选择器)和上下文无关的HTML标签对匹配器。 使用ZenCoding编写代码时，需要遵循一定的缩写规则： E元素名（div、p）； E#id带Id的元素（div#content、p#intro、span#error）； E.class带class的的元素（div.header、p.error）,id和class可以连着写，div#content.column E&gt;N子元素（div&gt;p、div#footer&gt;p&gt;span） EN多项元素（ul#nav&gt;li5&gt;a） E+N多项元素 E$*N带序号的元素 SublimeTmpl（自定义新建文件） 下载：https://github.com/kairyou/SublimeTmpl 默认已经添加了html、css、js等常见类型的面板，按ctrl+alt+h/ctrl+alt+c/ctrl+alt+j可新建这 3钟类型的文件，快捷键在这里\\Packages\\SublimeTmpl\\Default (Windows).sublime-keymap, 模板文件在这里\\Packages\\SublimeTmpl\\templates，可修改。 其他插件： Clipboard-history（粘贴板历史记录） 下载：https://github.com/kemayo/sublime-text-2-clipboard-history CSScomb（CSS属性排序） 下载：https://github.com/csscomb/CSScomb-for-Sublime Gits（集成 GitHub） 下载：https://github.com/kemayo/sublime-text-git Hex-to-HSL-Color Hex（颜色模式转HSL颜色模式） 下载：https://github.com/atadams/Hex-to-HSL-Color HtmlTidy（清理与排版你的HTML代码） 下载：https://github.com/welovewordpress/SublimeHtmlTidy JsFormat（javascript格式化） 下载：https://github.com/jdc0589/JsFormat PHPTidy（整理与排版PHP代码） 下载：https://github.com/welovewordpress/SublimePhpTidy SideBarEnhancements（侧边栏增强） 下载：https://github.com/titoBouzout/SideBarEnhancements SublimeLinter（代码错误提示） 下载：https://github.com/SublimeLinter/SublimeLinter/tree/sublime-text-3 SFTP（编辑 FTP 或 SFTP 服务器上的文件） 下载：http://wbond.net/sublime_packages/sftp Tradsim（中文繁字体和简体字转换） 下载：https://github.com/erinata/SublimeTradsim TrailingSpacer（高亮显示多余的空格和Tab） 下载：https://github.com/SublimeText/TrailingSpaces YUI Compressor（压缩JS和CSS文件） 下载：https://github.com/kairyou/SublimeYUICompressor 参考资料 http://www.imjeff.cn/blog/146/ http://blog.csdn.net/idxuanjun/article/details/13292847 http://my.oschina.net/theforever/blog/136554","tags":[{"name":"工具","slug":"工具","permalink":"//star45.me/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"//star45.me/tags/Sublime-Text-3/"}]},{"title":"Sublime Text 3 《第二章 - 介绍》","date":"2017-01-11T10:10:48.000Z","path":"2017/01/11/Sublime-Text-3-《第二章-介绍》/","text":"工欲善其事，必先利其器二、Sublime Text 3 介绍 Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。Sublime Text具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。2012年6月26日推出新版本的Sublime Text 2.0，与之前版本相比主要有较大的改善：支持 Retina 视网膜屏、快速跳到下一个、文本拖放、改善构建系统、CSS 自动完成和高亮设置等。 以上的介绍是引用了百度百科上对Sublime text的解释。 SublimeText是一款非常精巧的文本编辑器，适合编写代码、做笔记、写文章。它用户界面十分整洁，功能非同凡响，性能快得出奇。 这些非常棒的特性 包括： 任意跳转（Goto Anything）、 多重选择（multiple selections）、 指令面板（command palette）、 免打扰模式（distraction free mode）、 分区编辑（split editing）、 快速项目切换（instant project switch）， 你还可以随意地自定义更多功能。 还有，这款编辑器支持Mac、Windows和Linux平台。 SublimeText本身已经非常强大，但是更棒的是有一长串的插件支持它，给它带来更强大的功能。 本文将介绍一些 Sublime Text 3 支持的热门插件（Sublime Text 2 的一些插件在 Sublime Text 3 上不支持）。 以下所讲到的安装包和插件下载地址","tags":[{"name":"工具","slug":"工具","permalink":"//star45.me/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"//star45.me/tags/Sublime-Text-3/"}]},{"title":"Sublime Text 3 《第一章 - 引入》","date":"2017-01-11T10:04:45.000Z","path":"2017/01/11/Sublime-Text-3-《第一章-引入》/","text":"工欲善其事，必先利其器Sublime Text 3 引入 Sublime Text 3 一个如此性感无比的代码编辑器!程序员必备神器!跨平台… Sublime Text 3 是什么 我们为什么要用Sublime Text3 Sublime Text 3 会给我们带来什么 我们带着这些问题，去认识、学习Sublime Text 3 以下所讲到的安装包和插件下载地址","tags":[{"name":"工具","slug":"工具","permalink":"//star45.me/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"//star45.me/tags/Sublime-Text-3/"}]}]