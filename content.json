[{"title":"Spring-Rest","date":"2018-01-19T04:02:45.000Z","path":"2018/01/19/spring/Spring-rest/","text":"Rest风格接口 Springboot，Swagger，yaml，Rest，跨域，ajax[get、post、put、delete] swagger生成RestApi接口swagger-editor本地搭建 使用yaml语言手动编写接口。不建议使用Swagger注解在java工程里写，这样会导致代码太耦合与文档。 下载swagger-editor，1git clone https://github.com/swagger-api/swagger-editor.git 官方地址 https://swagger.io/download-page/， 使用npm下载通过http-server 启动该服务。运行如下命令 npm install -g http-server，这是指安装http-server服务器，-g是指全局安装，在安装nodejs时可指定全局位置，具体可以去网上搜索看如何指定位置，不指定也没影响，这里不详细说明。 启动 swagger-editor 服务。使用nodejs服务启动。 后面会讲使用java启动，嵌入到自己的web项目中。 1http-server swagger-editor -p 8089 启动界面如下： 访问界面如下：借助于swagger-UI强大的展示界面 yaml编写rest接口 yaml一种配件文件类似json，这里不多讲。关于swagger-editor支持的yaml语法比较简单。这个是API接口语法 spring-rest-url01。官方有现成的demo可以拿来直接用。先面讲一下我在生产环境遇到的问题。 rest接口部署 这里讲的API接口都是部署在自己WEB项目中。使用于swagger-UI + yaml 文件展示。swagger-UI下载：1git clone https://github.com/swagger-api/swagger-ui 目前使用的版本是3.X 。唯一不足的没有中文支持。2.X是支持中文界面的。大概所有需要文件有，以下是文件目录： 需要修改一下，index.html中引入yaml文件的路径。使用swagger-editor编辑完的yaml代码。copy到对应的 xxx.yaml文件中。 就可以访问该目录下的index.html文件。访问地址：http://你的项目地址/apiv3/index.hltml token的验证 因为后台API接口有token验证，所以文档需要支持token，为了这个折腾了好久。下面是正常的例子。123456789101112131415# 安全相关securityDefinitions: petstore_auth: type: \"oauth2\" authorizationUrl: \"http://petstore.swagger.io/oauth/dialog\" flow: \"implicit\" scopes: write:pets: \"modify pets in your account\" read:pets: \"read your pets\" APIKey: type: \"apiKey\" name: \"token\" in: \"header\"security: - APIKey: [] 授权验证： 请求接口：以后所有的请求接口都会带入token值，通过httpheader。 跨域问题 使用swagger-ui的接口文档访问后台一般都是前后分离部署，就会有跨域问题。解决方法有很多，nginx代理、手动修改Request和response请求类型。最简单的解决方法就是用Tomcat提供的Filter。如果请求的Url会有自定义的属性在httpheader中，需要扩展cors.allowed.headers下的属性，例如增加token 1234567891011121314151617181920212223242526272829303132&lt;filter&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.catalina.filters.CorsFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.origins&lt;/param-name&gt; &lt;param-value&gt;*&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.methods&lt;/param-name&gt; &lt;param-value&gt;GET,POST,PUT,DELETE,HEAD,OPTIONS&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.allowed.headers&lt;/param-name&gt; &lt;param-value&gt;token,Content-Type,X-Requested-With,accept,Origin,Access-Control-Request-Method,Access-Control-Request-Headers&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.exposed.headers&lt;/param-name&gt; &lt;param-value&gt;Access-Control-Allow-Origin,Access-Control-Allow-Credentials&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.support.credentials&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;cors.preflight.maxage&lt;/param-name&gt; &lt;param-value&gt;10&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;CorsFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 使用yaml接口文件，生成html和pdf接口描述文档 待更新 ##","tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.star45.xyz/tags/Spring/"},{"name":"Rest","slug":"Rest","permalink":"http://www.star45.xyz/tags/Rest/"},{"name":"Api","slug":"Api","permalink":"http://www.star45.xyz/tags/Api/"},{"name":"Swagger","slug":"Swagger","permalink":"http://www.star45.xyz/tags/Swagger/"}]},{"title":"log系列2-Logback","date":"2017-08-15T05:02:45.000Z","path":"2017/08/15/log/log系列2-logback/","text":"Logback学习概述 LogBack是一个日志框架，它与Log4j可以说是同出一源，都出自Ceki Gülcü之手。（log4j的原型是早前由Ceki Gülcü贡献给Apache基金会的）下载地址：http://logback.qos.ch/download.html LogBack、Slf4j和Log4j之间的关系Slf4j是The Simple Logging Facade for Java的简称，是一个简单日志门面抽象框架，它本身只提供了日志Facade API和一个简单的日志类实现，一般常配合Log4j，LogBack，java.util.logging使用。Slf4j作为应用层的Log接入时，程序可以根据实际应用场景动态调整底层的日志实现框架(Log4j/LogBack/JdkLog…)。 LogBack和Log4j都是开源日记工具库，LogBack是Log4j的改良版本，比Log4j拥有更多的特性，同时也带来很大性能提升。详细数据可参照下面地址：Reasons to prefer logback over log4j。 LogBack官方建议配合Slf4j使用，这样可以灵活地替换底层日志框架。 LogBack的结构LogBack被分为3个组件，logback-core, logback-classic 和 logback-access。 [x] logback-core提供了LogBack的核心功能，是另外两个组件的基础。 [x] logback-classic则实现了Slf4j的API，所以当想配合Slf4j使用时，需要将logback-classic加入classpath。 [x] logback-access是为了集成Servlet环境而准备的，可提供HTTP-access的日志接口。 配置详解根节点包含的属性 scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true. scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟. debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 123&lt;configuration scan=\"true\" scanPeriod=\"60 second\" debug=\"false\"&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 根节点的子节点LogBack的配置大概包括3部分：appender, logger和root。这里写图片描述 设置上下文名称 每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改。 123456789101112131415161718 &lt;configuration scan=\"true\" scanPeriod=\"60 second\" debug=\"false\"&gt; &lt;contextName&gt;myAppName&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; ``` 2. 设置变量 &lt;property&gt; 用来定义变量值的标签，&lt;property&gt; 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过&lt;property&gt;定义的值会被插入到logger上下文中。定义变量后，可以使“$&#123;&#125;”来使用变量。 例如使用&lt;property&gt;定义上下文名称，然后在&lt;contentName&gt;设置logger上下文时使用。 ```xml &lt;configuration scan=\"true\" scanPeriod=\"60 second\" debug=\"false\"&gt; &lt;property name=\"APP_Name\" value=\"myAppName\" /&gt; &lt;contextName&gt;$&#123;APP_Name&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 获取时间戳字符串 两个属性 key:标识此 的名字；datePattern：设置将当前时间（解析配置文件的时间）转换为字符串的模式，遵循Java.txt.SimpleDateFormat的格式。 例如将解析配置文件的时间作为上下文名称： 12345&lt;configuration scan=\"true\" scanPeriod=\"60 second\" debug=\"false\"&gt; &lt;timestamp key=\"bySecond\" datePattern=\"yyyyMMdd'T'HHmmss\"/&gt; &lt;contextName&gt;$&#123;bySecond&#125;&lt;/contextName&gt; &lt;!-- 其他配置省略--&gt; &lt;/configuration&gt; 设置logger和root 用来设置某一个包或者具体的某一个类的日志打印级别、以及指定。仅有一个name属性，一个可选的level和一个可选的addtivity属性。 name：用来指定受此logger约束的某一个包或者具体的某一个类。 level：用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特殊值INHERITED或者同义词NULL，代表强制执行上级的级别。 如果未设置此属性，那么当前logger将会继承上级的级别。 addtivity：是否向上级logger传递打印信息。默认是true。 可以包含零个或多个元素，标识这个appender将会添加到这个logger。 也是元素，但是它是根logger。只有一个level属性，应为已经被命名为”root”. level：用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL。默认是DEBUG。 可以包含零个或多个元素，标识这个appender将会添加到这个logger。 案例介绍 首先，Java类如下： 123456789101112131415package logback; import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class LogbackDemo &#123; private static Logger log = LoggerFactory.getLogger(LogbackDemo.class); public static void main(String[] args) &#123; log.trace(\"======trace\"); log.debug(\"======debug\"); log.info(\"======info\"); log.warn(\"======warn\"); log.error(\"======error\"); &#125; &#125; logback.xml配置文件（只配置root） 1234567891011121314&lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt; &lt;/configuration&gt; 其中appender的配置表示打印到控制台(稍后详细讲解appender )。将root的打印级别设置为“INFO”，指定了名字为“STDOUT”的appender。 当执行logback.LogbackDemo类的main方法时，root将级别为“INFO”及大于“INFO”的日志信息交给已经配置好的名为“STDOUT”的appender处理，“STDOUT”appender将信息打印到控制台； 输出结果： 13:30:38.484 [main] INFO logback.LogbackDemo - ======info 13:30:38.500 [main] WARN logback.LogbackDemo - ======warn 13:30:38.500 [main] ERROR logback.LogbackDemo - ======error 带有logger的配置，不指定级别，不指定appender 1234567891011121314151617&lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name=\"logback\"/&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt; &lt;/configuration&gt; 其中appender的配置表示打印到控制台。 输出结果： 13:19:15.406 [main] DEBUG logback.LogbackDemo - ======debug 13:19:15.406 [main] INFO logback.LogbackDemo - ======info 13:19:15.406 [main] WARN logback.LogbackDemo - ======warn 13:19:15.406 [main] ERROR logback.LogbackDemo - ======error 将控制logback包下的所有类的日志的打印，但是并没有设置打印级别，所以继承他的上级的日志级别“DEBUG”。 没有设置addtivity，默认为true，将此logger的打印信息向上级传递。 没有设置appender，此logger本身不打印任何信息。 将root的打印级别设置为“DEBUG”，指定了名字为“STDOUT”的appender。 当执行logback.LogbackDemo类的main方法时，因为LogbackDemo 在包logback中，所以首先执行，将级别为“DEBUG”及大于“DEBUG”的日志信息传递给root，本身并不打印。 root接到下级传递的信息，交给已经配置好的名为“STDOUT”的appender处理，“STDOUT”appender将信息打印到控制台。 带有多个logger的配置，指定级别，指定appender 12345678910111213141516171819 &lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- encoder 默认配置为PatternLayoutEncoder --&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name=\"logback\"/&gt; &lt;!--logback.LogbackDemo：类的全路径 --&gt; &lt;logger name=\"logback.LogbackDemo\" level=\"INFO\" additivity=\"false\"&gt; &lt;appender-ref ref=\"STDOUT\"/&gt; &lt;/logger&gt; &lt;root level=\"ERROR\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt; &lt;/configuration&gt; 输出结果： 14:05:35.937 [main] INFO logback.LogbackDemo - ======info14:05:35.937 [main] WARN logback.LogbackDemo - ======warn14:05:35.937 [main] ERROR logback.LogbackDemo - ======error 将控制logback包下的所有类的日志的打印，但是并没用设置打印级别，所以继承他的上级的日志级别“DEBUG”。 没有设置addtivity，默认为true，将此logger的打印信息向上级传递。 没有设置appender，此logger本身不打印任何信息。 控制logback.LogbackDemo类的日志打印，打印级别为“INFO”。additivity属性为false，表示此logger的打印信息不再向上级传递，指定了名字为“STDOUT”的appender。 将root的打印级别设置为“ERROR”，指定了名字为“STDOUT”的appender。 当执行logback.LogbackDemo类的main方法时，先执行，将级别为“INFO”及大于“INFO”的日志信息交给此logger指定的名为“STDOUT”的appender处理，在控制台中打出日志，不再向次logger的上级 传递打印信息。 未接到任何打印信息，当然也不会给它的上级root传递任何打印信息。 如果将修改为 那打印结果将是什么呢？没错，日志打印了两次，想必大家都知道原因了，因为打印信息向上级传递，logger本身打印一次，root接到后又打印一次： 14:09:01.531 [main] INFO logback.LogbackDemo - ======info14:09:01.531 [main] INFO logback.LogbackDemo - ======info14:09:01.531 [main] WARN logback.LogbackDemo - ======warn14:09:01.531 [main] WARN logback.LogbackDemo - ======warn14:09:01.531 [main] ERROR logback.LogbackDemo - ======error14:09:01.531 [main] ERROR logback.LogbackDemo - ======error 详解是的子节点，是负责写日志的组件。有两个必要属性name和class。name指定appender名称，class指定appender的全限定名。 这里写图片描述 ConsoleAppender把日志添加到控制台，有以下子节点： 12345678910111213&lt;encoder&gt;：对日志进行格式化。（具体参数稍后讲解 ）&lt;target&gt;：字符串 System.out 或者 System.err ，默认 System.out .&lt;configuration&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"STDOUT\" /&gt; &lt;/root&gt; &lt;/configuration&gt; FileAppender把日志添加到文件，有以下子节点： ：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 ：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 ：对记录事件进行格式化。（具体参数稍后讲解 ） ：如果是 true，日志会被安全的写入文件，即使其他的FileAppender也在向此文件做写入操作，效率低，默认是 false。 12345678910111213&lt;configuration&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.FileAppender\"&gt; &lt;file&gt;testFile.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt; &lt;/configuration&gt; RollingFIleAppender滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件。有以下子节点： ：被写入的文件名，可以是相对目录，也可以是绝对目录，如果上级目录不存在会自动创建，没有默认值。 ：如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true。 ：对记录事件进行格式化。（具体参数稍后讲解 ） :当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 : 告知 RollingFileAppender 何时激活滚动。 ：当为true时，不支持FixedWindowRollingPolicy。支持TimeBasedRollingPolicy，但是有两个限制，1不支持也不允许文件压缩，2不能设置file属性，必须留空。 rollingPolicy TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责触发滚动。有以下子节点： : 必要节点，包含文件名及“%d”转换符，%d”可以包含一个Java.text.SimpleDateFormat指定的时间格式，如：%d{yyyy-MM}。如果直接使用 %d，默认格式是 yyyy-MM-dd。RollingFileAppender 的file字节点可有可无，通过设置file，可以为活动文件和归档文件指定不同位置，当前日志总是记录到file指定的文件（活动文件），活动文件的名字不会改变；如果没设置file，活动文件的名字会根据fileNamePattern 的值，每隔一段时间改变一次。“/”或者“\\”会被当做目录分隔符。 : 可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每个月滚动，且是6，则只保存最近6个月的文件，删除之前的旧文件。注意，删除旧文件是，那些为了归档而创建的目录也会被删除。 FixedWindowRollingPolicy： 根据固定窗口算法重命名文件的滚动策略。有以下子节点： :窗口索引最小值。 :窗口索引最大值，当用户指定的窗口过大时，会自动将窗口设置为12。 : 必须包含“%i”例如，假设最小值和最大值分别为1和2，命名模式为 mylog%i.log,会产生归档文件mylog1.log和mylog2.log。还可以指定文件压缩选项，例如，mylog%i.log.gz 或者 没有log%i.log.zip triggeringPolicy SizeBasedTriggeringPolicy： 查看当前活动文件的大小，如果超过指定大小会告知RollingFileAppender 触发当前活动文件滚动。只有一个节点: :这是活动文件的大小，默认值是10MB。 例如：每天生产一个日志文件，保存30天的日志文件1234567891011121314151617&lt;configuration&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;logFile.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt; &lt;/configuration&gt; 又例如：按照固定窗口模式生成日志文件，当文件大于20MB时，生成新的日志文件。窗口大小是1到3，当保存了3个归档文件后，将覆盖最早的日志。12345678910111213141516171819202122&lt;configuration&gt; &lt;appender name=\"FILE\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;test.log&lt;/file&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.FixedWindowRollingPolicy\"&gt; &lt;fileNamePattern&gt;tests.%i.log.zip&lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;3&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;triggeringPolicy class=\"ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\"&gt; &lt;maxFileSize&gt;5MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"FILE\" /&gt; &lt;/root&gt; &lt;/configuration&gt; 另外还有SocketAppender、SMTPAppender、DBAppender、SyslogAppender、SiftingAppender，并不常用，这些就不在这里讲解了，大家可以参考官方文档。当然大家可以编写自己的Appender。负责两件事，一是把日志信息转换成字节数组，二是把字节数组写入到输出流。目前PatternLayoutEncoder 是唯一有用的且默认的encoder ，有一个节点，用来设置日志的输入格式。使用“%”加“转换符”方式，如果要输出“%”，则必须用“\\”对“\\%”进行转义。例如：123&lt;encoder&gt; &lt;pattern&gt;%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; 格式修饰符，与转换符共同使用：可选的格式修饰符位于“%”和转换符之间。第一个可选修饰符是左对齐 标志，符号是减号“-”；接着是可选的最小宽度 修饰符，用十进制数表示。如果字符小于最小宽度，则左填充或右填充，默认是左填充（即右对齐），填充符为空格。如果字符大于最小宽度，字符永远不会被截断。最大宽度 修饰符，符号是点号”.”后面加十进制数。如果字符大于最大宽度，则从前面截断。点符号“.”后面加减号“-”在加数字，表示从尾部截断。 例如：%-4relative 表示，将输出从程序启动到创建日志记录的时间 进行左对齐 且最小宽度为4。 以上格式说明如下： - %m 输出代码中指定的消息 - %p 输出优先级，即DEBUG，INFO，WARN，ERROR，FATAL - %r 输出自应用启动到输出该log信息耗费的毫秒数 - %c 输出所属的类目，通常就是所在类的全名 - %t 输出产生该日志事件的线程名 - %n 输出一个回车换行符，Windows平台为“\\r\\n”，Unix平台为“\\n” - %d 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyy MMM dd HH:mm:ss,SSS}，输出类似：2002年10月18日 22：10：28，921 - %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.Java:10) 生产环境配置案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;configuration scan=\"true\" scanPeriod=\"60 second\" debug=\"false\"&gt; &lt;property resource=\"application.properties\"/&gt; &lt;substitutionProperty name=\"PROJECT_NAME\" value=\"restful\"/&gt; &lt;substitutionProperty name=\"LOG_HOME\" value=\"./logs\"/&gt; &lt;property name=\"pattern\" value=\"[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%5level] [%thread] %logger&#123;0&#125;-%L %msg%n\"&gt;&lt;/property&gt; &lt;timestamp key=\"byDate\" datePattern=\"yyyyMMdd\" timeReference=\"contextBirth\"/&gt; &lt;!-- 负责写日志,控制台日志 --&gt; &lt;appender name=\"STDOUT\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;encoder&gt; &lt;pattern &gt;$&#123;pattern&#125;&lt;/pattern&gt; &lt;immediateFlush&gt;true&lt;/immediateFlush&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 文件日志 --&gt; &lt;appender name=\"restRolling\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;file&gt;$&#123;LOG_HOME&#125;/restful.log&lt;/file&gt; &lt;!--如果是 true，日志被追加到文件结尾，如果是 false，清空现存文件，默认是true--&gt; &lt;append&gt;false&lt;/append&gt; &lt;!--日志会被安全的写入文件--&gt; &lt;prudent&gt;false&lt;/prudent&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;pattern&#125;&lt;/pattern&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!--&lt;immediateFlush&gt;true&lt;/immediateFlush&gt;--&gt; &lt;/encoder&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;LOG_HOME&#125;/restful.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!-- - 1.name：包名或类名，用来指定受此logger约束的某一个包或者具体的某一个类 - 2.未设置打印级别，所以继承他的上级&lt;root&gt;的日志级别“DEBUG” - 3.未设置additivity，默认为true，将此logger的打印信息向上级传递； - 4.未设置appender，此logger本身不打印任何信息，级别为“DEBUG”及大于“DEBUG”的日志信息传递给root， - root接到下级传递的信息，交给已经配置好的名为“STDOUT”的appender处理，“STDOUT”appender将信息打印到控制台； --&gt; &lt;!--dubbo--&gt; &lt;logger name=\"com.alibaba.dubbo\" level=\"WARN\"&gt;&lt;/logger&gt; &lt;!--spring--&gt; &lt;logger name=\"org.springframework\" level=\"WARN\"&gt;&lt;/logger&gt; &lt;!--logback--&gt; &lt;logger name=\"ch.qos.logback\" level=\"WARN\"&gt;&lt;/logger&gt; &lt;logger name=\"org.apache.zookeeper\" level=\"WARN\"&gt;&lt;/logger&gt; &lt;logger name=\"com.gome.item.rest\" level=\"DEBUG\"&gt;&lt;/logger&gt; &lt;root level=\"WARN\"&gt; &lt;appender-ref ref=\"STDOUT\"/&gt; &lt;appender-ref ref=\"restRolling\"/&gt; &lt;/root&gt;&lt;/configuration&gt;","tags":[{"name":"java","slug":"java","permalink":"http://www.star45.xyz/tags/java/"},{"name":"Log","slug":"Log","permalink":"http://www.star45.xyz/tags/Log/"}]},{"title":"log系列1-log4j","date":"2017-08-10T05:02:45.000Z","path":"2017/08/10/log/log系列1-Log4j/","text":"运行过程中配置log4j在java运行过程中，可以通过初始化一个properties文件设置log4j的配置参数。然后通过PropertyConfigurator类将该properties文件加载到log4j运行的配置类中。 12345678private static void initLog4j() &#123; Properties prop = new Properties(); prop.setProperty(\"log4j.rootLogger\", \"DEBUG, CONSOLE\"); prop.setProperty(\"log4j.appender.CONSOLE\", \"org.apache.log4j.ConsoleAppender\"); prop.setProperty(\"log4j.appender.CONSOLE.layout\", \"org.apache.log4j.PatternLayout\"); prop.setProperty(\"log4j.appender.CONSOLE.layout.ConversionPattern\", \"%d&#123;HH:mm:ss,SSS&#125; [%t] %-5p %C&#123;1&#125; : %m%n\"); PropertyConfigurator.configure(prop);&#125;","tags":[{"name":"java","slug":"java","permalink":"http://www.star45.xyz/tags/java/"},{"name":"Log","slug":"Log","permalink":"http://www.star45.xyz/tags/Log/"}]},{"title":"googel-guava-生产问题","date":"2017-06-21T09:13:07.000Z","path":"2017/06/21/google-guava/googel-guava-生产问题/","text":"Google Guava实际开发遇到的问题总结Guava Lists.transform dubbo请求序列化问题问题引发今天遇到一个问题，大概是这样的：使用了guava的Lists.transform对一个ArrayList进行转化后，做一个dubbo的请求参数，发生异常。但是使用原生态的ArrayList是没问题的。在实际工作中我们经常对一个List集合进行转化，常用的就是for循环和forEach。google Guava提供的 transform可以做到更优雅。看例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344//TODO 批量缓存圈子信息private Map&lt;String,String&gt; cacheGomeShopGroupItem(List&lt;GomeStoreItem&gt; gomeStoreItems)&#123; final Map&lt;String,String&gt; shopGroupMap = Maps.newHashMap(); //1、普通for循环 List&lt;String&gt; storeIds = Lists.newArrayList(); for (int i = 0; i &lt;gomeStoreItems.size()&amp;&amp;gomeStoreItems!=null ; i++) &#123; GomeStoreItem gomeStoreItem = gomeStoreItems.get(i); String storeId = null; if (gomeStoreItem != null)&#123; storeId = gomeStoreItem.getGomeStoreId(); &#125; storeIds.add(storeId); &#125; //2、使用transform转化 List&lt;String&gt; storeIds1 = Lists.newArrayList(); storeIds1.addAll(Lists.transform(gomeStoreItems, new Function&lt;GomeStoreItem, String&gt;() &#123; @Nullable @Override public String apply(@Nullable GomeStoreItem gomeStoreItem) &#123; return gomeStoreItem.getGomeStoreId(); &#125; &#125;)); List&lt;GomeShopGroupItem&gt; shopGroupItems = Lists.newArrayList(); try &#123; //正常的dubbo调用 CommonResultEntity&lt;List&lt;ShopGroupInfo&gt;&gt; resuletEntity = opensocialGroupFacade.shopGroupInfo(storeIds); //非正常的dubbo调用 CommonResultEntity&lt;List&lt;ShopGroupInfo&gt;&gt; resuletEntity1 = opensocialGroupFacade.shopGroupInfo(storeIds1); // 业务代码 ...... &#125; catch (Exception e) &#123; logger.error(String.format(\"查询圈子出错：storeIds：%s\",JSON.toJSONString(storeIds))); &#125; return shopGroupMap; &#125; 问题分析以下是使用transform转化的List,使用dubbo调用发生的异常信息： 12Failed to invoke the method shopGroupInfo in the service cn.com.mx.opensocial.group.service.IOpensocialGroupFacade. Tried 3 times of the providers [10.125.198.49:30006] (1/1) from the registry 10.125.198.74:2181 on the consumer 10.144.36.140 using the dubbo version 2.5.5.cat-SNAPSHOT. Last error is: Failed to invoke remote method: shopGroupInfo, provider: dubbo://10.125.198.49:30006/cn.com.mx.opensocial.group.service.IOpensocialGroupFacade?anyhost=true&amp;application=gome-detail-service&amp;check=false&amp;default.accepts=1000&amp;default.check=false&amp;default.timeout=5000&amp;dubbo=2.5.3&amp;heartbeat=100000&amp;interface=cn.com.mx.opensocial.group.service.IOpensocialGroupFacade&amp;methods=shopGroupInfo,strollGroups,checkIsMember&amp;owner=qiantai&amp;pid=4876&amp;providerside=venus-opensocial&amp;revision=1.1&amp;serialization=nativejava&amp;side=consumer&amp;timeout=8000&amp;timestamp=1498030003360&amp;version=1.0.0, cause: Failed to send message Request [id=12, version=2.0.0, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=shopGroupInfo, parameterTypes=[interface java.util.List], arguments=[[1, 6, 10, 20, 30, 31, 40, 10122, 10132, 10138, 10140, 10142, 10145, 10146, 10150, 10159]], attachments=&#123;_catChildMessageId=gome-detail-service-0a90248c-416119-487610019, _catParentMessageId=gome-detail-service-0a90248c-416119-487610018, _rStrategy=null, path=cn.com.mx.opensocial.group.service.IOpensocialGroupFacade, consumerside=gome-detail-service, interface=cn.com.mx.opensocial.group.service.IOpensocialGroupFacade, _catRootMessageId=gome-detail-service-0a90248c-416119-487610018, @null=null, timeout=8000, version=1.0.0&#125;]] to /10.125.198.49:30006, cause: com.gome.item.services.GomeStoreServiceImpl$2 cause: Failed to send message 可以看出发送请求的时候就失败了。那么第一考虑到的就是序列化，因为一次rpc调用肯定需要将参数序列化。 1、ArrayList 实现了 java.io.Serializable接口；2、使用transform生成的TransformingRandomAccessList 并不是ArrayList类型并没有实现序列化接口， 带着问题去查看guava源码：123456789101112/** * Returns a list that applies &#123;@code function&#125; to each element of &#123;@code * fromList&#125;. The returned list is a transformed view of &#123;@code fromList&#125;; * changes to &#123;@code fromList&#125; will be reflected in the returned list and vice * versa. * * &lt;p&gt;Since functions are not reversible, the transform is one-way and new * items cannot be stored in the returned list. The &#123;@code add&#125;, * &#123;@code addAll&#125; and &#123;@code set&#125; methods are unsupported in the returned * list. ........ */ 大概意思：123456/** * 该方法返回一个列表，这个列表中元素是运用方法中传入的功能函数(Function)对原列表中的元素进行处理后的结果, * 它是原列表的一个功能视图，任何对原列表的改变将会体现到视图列表中。因为Function函数是不可逆的， * 所以这样的转换是单向的，并且转换的结果不能存储在返回的列表中。 * 所有对视图列表的添加（add/addAll）、设置（set）等都是不被支持的。 */ 所以说，返回的对象列表是一个视图，其中对它的任何更改都是无效的，并且也不建议对视图对象产生更改，如果需要更改返回的列表，那么需要自己进一步包装，如Lists.newArrayList(retList);如果需要对返回的结果视图进行处理：12List&lt;String&gt; storeIdsArrayList = Lists.newArrayList(storeIds); 这样就可以正常的去做为一个rpc请求的参数了。","tags":[{"name":"Framework","slug":"Framework","permalink":"http://www.star45.xyz/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"http://www.star45.xyz/tags/Guava/"}]},{"title":"SpringBoot 1","date":"2017-05-13T04:02:45.000Z","path":"2017/05/13/spring/SpringBoot/","text":"SpringBootspringboot 整合dubbo使用 xml方式。 用Dubbo做过几个项目了，从来没有碰到过Caused by: Java.lang.ClassCastException这种错误，最后经过反复的测试发现原来是因为依赖了SpringBoot的开发者工具才出现的这一个问题，只要把下面的依赖去掉就解决了这一个问题： &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; 1. 如果你需要在SpringApplication初始化的时候就做一些事情，使用ApplicationContextInitializer 如果你需要SpringApplication的某个特定阶段做一些事情，使用ApplicationListener（推荐） 如果你需要在beanFactory层面上开发，使用BeanFactoryPostProcessor（推荐） 如果你需要在对某个bean的实例化层面上开发，使用BeanPostProcessor（一般业务上的开发使用InitializingBean或者init-method能够满足）","tags":[{"name":"Framework","slug":"Framework","permalink":"http://www.star45.xyz/tags/Framework/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://www.star45.xyz/tags/SpringBoot/"}]},{"title":"google-guava-functional","date":"2017-04-19T09:18:21.000Z","path":"2017/04/19/google-guava/google-guava4-functional/","text":"Google Guava学习","tags":[{"name":"Framework","slug":"Framework","permalink":"http://www.star45.xyz/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"http://www.star45.xyz/tags/Guava/"}]},{"title":"google-guava-caches","date":"2017-04-19T09:18:00.000Z","path":"2017/04/19/google-guava/google-guava3-caches/","text":"Google Guava学习","tags":[{"name":"Framework","slug":"Framework","permalink":"http://www.star45.xyz/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"http://www.star45.xyz/tags/Guava/"}]},{"title":"google-guava-collections","date":"2017-04-19T09:17:35.000Z","path":"2017/04/19/google-guava/google-guava2-collections/","text":"GoogleGuava学习 使用Guava里的Collections，你将受益不菲。它能大量减少你工程里那些样本式的代码 (同时你还能使用它提供的新的速度更快的数据结构！). Google Collection 实现 实际开发应用 题外话：前几天开发一个功能的时候，需要一个复杂的数据接口。一个Map里面key-value结构，value的值是使用List。还需要排序、遍历检索等操作，虽然在机器中的运算是比较快的，但是整体的代码比较臃肿。这时候在review同事的代码中发现一个优秀的类库google-guava中的collection。一旦上手发现太爽了。 123456Multimap&lt;Integer, WarrantyBean&gt; warrantyMultimap = ArrayListMultimap.create();for (WarrantyBean warrantyBean : result)&#123; Integer typeKey = warrantyBean.getProductWarrantyType(); warrantyMultimap.put(typeKey,warrantyBean);&#125;Map&lt;Integer,Collection&lt;WarrantyBean&gt;&gt; warrantyMap = warrantyMultimap.asMap(); 这样可以在一次for循环中得到一个Map","tags":[{"name":"Framework","slug":"Framework","permalink":"http://www.star45.xyz/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"http://www.star45.xyz/tags/Guava/"}]},{"title":"google-guava1-basic","date":"2017-04-19T09:13:07.000Z","path":"2017/04/19/google-guava/google-guava1-basic/","text":"","tags":[{"name":"Framework","slug":"Framework","permalink":"http://www.star45.xyz/tags/Framework/"},{"name":"Guava","slug":"Guava","permalink":"http://www.star45.xyz/tags/Guava/"}]},{"title":"面试","date":"2017-03-28T08:15:24.000Z","path":"2017/03/28/杂事/面试/","text":"一些java面试问题总结Java基础 Hashtable和HashMap的区别。 抽象类与接口的区别。 final关键字的使用和区别。 异常分类和处理机制。 JDK版本区别。 StringBuilder内部实现机制。 反射机制的使用。 匿名内部类的使用。 泛型的概念和使用。 弱引用和虚引用的概念和使用方式。 开源框架 SpringMVC和Struts2的区别 Spring IOC和AOP的概念以及实现方式 Spring事务的管理 Hibernate与MyBatis的比较 Hibernate延迟加载的机制 JVM虚拟机 GC算法有哪些 垃圾回收器有哪些 如何调优JVM 缓存和NoSQL 缓存的使用场景 缓存命中率的计算 Memcache与Redis的比较 如何实现Redis的分片 MongoDB的特点 分布式 zookeeper的用途 dubbo的用途以及优点 dubbo的实现原理 数据结构和算法 单向链表的逆序排列 双向链表的操作 1亿个整数的倒序输出 找出给定字符串中最长回文（回文：abcdcba，两端对称） 网络编程 Get和Post的区别 Https协议的实现 长连接的管理 Socket的基本方法 数据库 inner join和left join的区别 复杂SQL语句 数据库优化方式 数据库拆分方式 如何保证不同数据结构的数据一致性 安全 什么是XSS攻击，具体如何实现？开放问题：如何保障系统安全？ 设计模式 写出一个设计模式的类图 设计模式的意义是什么 写个单例模式的代码 多线程 如何避免Quartz重复启动任务 线程池满了如何处理额外的请求 同一个对象的连个同步方法能否被两个线程同时调用 华丽丽的分割线 部分答案Java基础 HashMap和Hashtable的区别 HashMap是非线程安全的，Hashtable是线程安全的。 HashMap的键值都可以为null，Hashtable的键值都不可以为null值。 HashMap继承自AbstractMap类，Hashtable继承自Dictionary类。 ps : Properties类继承自Hashtable类。 异常分类和处理机制 分类： 运行时异常（Runtime Exception） 受检查异常（Checked Exception） 运行时异常： 必须继承RuntimeException类， 定义方法时不必声明会抛出运行时异常。 调用方法时不必捕获运行时异常。 受检查异常： 不继承自RumtimeException类 定义方法时需要抛出可能会抛出的Checked Exception 调用方法时需要捕获Checked Exception或者继续向上抛出。 逻辑上： 运行时异常：一般不需要或者不知道如何处理此类异常； 受检验异常：一般需要知道如何处理可能发生的异常情况。 StringBuilder内部实现机制 StringBuilder内部有一个字符数组，代码如下: char[] value; //字符数组 int count; //字符串长度 每一次append操作都是将新的字符串加入到可变长的字符数组中，长度计算方式与ArrayList类似。调用toString()方法时，new一个String对象即可。 123public String toString() &#123; return new String(value, 0, count);// Create a copy, don't share the array&#125; ps: StringBuffer是线程安全的，StringBuilder是非线程安全的。 匿名内部类的使用 匿名内部类是没有名字的类，只在某一处被使用，不会被多处调用，一般是某个父类或接口的特定实现。 强引用、软引用、弱引用和虚引用 强引用: 一般的引用都是强引用，即使OutOfMemory也不会回收这部分被把持的引用内存。 软引用（SoftReference）: 如果内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被使用。++软引用可以用来实现内存敏感的高速缓存。++ 弱引用（WeakReference）：弱引用的对象拥有更短暂的生命周期。当垃圾回收期发现只有若引用的对象，不论内存空间足够与否，都会回收它。 虚引用（）：虚引用不会决定对象的生命周期，如果一个对象仅持有一个虚引用，那么它随时可能被回收。++虚引用主要用来跟踪对象被垃圾回收器回收的活动。++ 更多关于『强、软、弱和虚引用』参考文章：http://zhangjunhd.blog.51cto…. 开源框架 SpringMVC和Struts2的区别 SpringMVC的方法级别的拦截，Struts2是类级别的拦截； SpringMVC是基于Servlet实现Controller，Struts2是基于Filter实现； SpringMVC性能和安全性高于Struts2； SpringMVC更加组件化和流程化，易于扩展，比如返回JSON通过设置@ResponseBody即可； Struts2更加无耦合，比较纯粹，但是需要更多的自行开发的代码以支持更多功能。 Spring事务的管理 分类：声明式事务、编程式事务 声明式事务：通过统一配置实现事务的统一管理，一般配置TransactionMananger以及相关属性即可。 编程式事务（注解方式）：在需要事务的方法上配置相关的注解（包括事务类型、回滚策略等） 事务类型： PROPAGATION_REQUIRED PROPAGATION_SUPPORTS3.PROPAGATION_MANDATORY PROPAGATION_REQUIRES_NEW PROPAGATION_NOT_SUPPORTED PROPAGATION_NEVER PROPAGATION_NESTED 事务隔离级别 ISOLATION_DEFAULT ISOLATION_READ_UNCOMMITTED ISOLATION_READ_COMMITTED ISOLATION_REPEATABLE_READ ISOLATION_SERIALIZABLE Hibernate与MyBatis的比较 Hibernate完全实现对象关系映射（ORM），MyBatis实现的是SQL Mapping MyBatis可以进行更为细致的SQL优化，可以减少查询字段。比Hibernate容易掌握，Hibernate门槛较高。 Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。 Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。 Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。 Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。 JVM虚拟机 GC算法有哪些 引用计数 复制 标记-清除 标记-压缩 分代（新生代、老年代、永久代） 垃圾回收器有哪些 串行回收器：新生代串行回收器、老年代串行回收器 并行回收器：新生代ParNew回收器、新生代ParallelGC回收器、老年代ParallelGC回收器 CMS回收器：（Concurrent Mark Sweep、并发标记清除） G1回收器（1.7以后代替CMS回收器） 如何调优JVM 标准参数： -client -server模式 -Xmn、-Xms、-Xmx 监控：jps、jstat、jinfo、jmap、jhat、jstack… Java 中堆和栈有什么区别？ JVM 中堆和栈属于不同的内存区域，使用目的也不同。 栈常用于保存方法帧和局部变量，而对象总是在堆上分配。 栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。 缓存和NoSQL 缓存命中率的计算 命中缓存次数/(命中缓存次数+未命中缓存次数) = 命中率 Memcache与Redis的区别 memcache把数据存在内存之中，断电后会挂掉；Redis部分数据持久化在硬盘上，断电不会丢失。 memcache存的是key-value对，redis支持更多的数据结构和数据类型 memcache可以使用一致性hash做分布式，redis可以做主从同步 redis单线程，只使用1个cpu 如何实现Redis的分片 使用一致性哈希对数据进行映射 实现方式：客户端分片（每个客户端对应一个分片）、代理协助分片、查询路由分片； 使用redis集群，如codis（豌豆荚，依赖zookeeper）； 分布式 zookeeper的用途 zookeeper作为分布式应用协调系统，已经用到很多分布式项目中。可以用来完成统一命名服务、状态同步服务、集群管理、分布式应用配置项等管理工作。 zookeeper的主要操作分一下几种： 创建节点 读取节点数据 更新节点数据 删除节点 监控节点变化 应用场景： 统一命名服务，使用create自动创建节点编号； 配置管理，多个节点的共享配置，当配置发生变化时，可利用zookeeper让使用这些配置的节点获得通知，进行重新加载等操作。如dubbo服务。 集群管理：集群选举主节点，资源定位。 共享锁 负载均衡 应用项目：dubbo服务集群、redis集群、Hadoop集群等 dubbo的用途以及优点 Dubbo是一个分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。 数据结构和算法 将单项链表逆序排列 将单向链表逆序输出，方法有三种： 遍历链表，将每个节点的内容存入一个数组中，然后逆序输出数组(最简单的做法) 使用栈来逆序输出 直接将链表（指针）逆序然后输出 单向链表详细信息参考文章：http://blog.csdn.net/jianyuer… 海量数据操作 十道面试题与十个海量数据处理方法总结 http://blog.csdn.net/v_july_v/article/details/6279498","tags":[{"name":"Java","slug":"Java","permalink":"http://www.star45.xyz/tags/Java/"}]},{"title":"Spring系列1-Filter","date":"2017-03-13T04:02:45.000Z","path":"2017/03/13/spring/Spring系列2-Ioc/","text":"SpringFramework提供的IOC1. IoC理论的背景耦合关系不仅会出现在对象与对象之间，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间。如何降低系统之间、模块之间和对象之间的耦合度，是软件工程永远追求的目标之一。为了解决对象之间的耦合度过高的问题，软件专家Michael Mattson提出了IOC理论，用来实现对象之间的“解耦”，目前这个理论已经被成功地应用到实践当中，很多的J2EE项目均采用了IOC框架产品spring。 2. 什么是控制反转(IoC)IOC是Inversion of Control的缩写，多数书籍翻译成“控制反转”。IOC理论提出的观点大体是这样的：借助于“第三方”实现具有依赖关系的对象之间的解耦。 我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：软件系统在没有引入IOC容器之前，如图1所示，对象A依赖于对象B，那么对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。无论是创建还是使用对象B，控制权都在自己手上。软件系统在引入IOC容器之后，这种情形就完全改变了，如图3所示，由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。通过前后的对比，我们不难看出来：对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。 3. IOC的别名：依赖注入(DI)依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。 4. IOC为我们带来了什么好处 组件之间低耦合或者无耦合带来的好处。 5. IOC容器的技术剖析IOC中最基本的技术就是“反射(Reflection)”编程 ##待更新##","tags":[{"name":"Spring","slug":"Spring","permalink":"http://www.star45.xyz/tags/Spring/"},{"name":"framework","slug":"framework","permalink":"http://www.star45.xyz/tags/framework/"}]},{"title":"Spring系列1-Filter","date":"2017-03-13T04:02:45.000Z","path":"2017/03/13/spring/Spring系列1-Filter/","text":"SpringFramework提供的filter,Spring提供的filter有如下这些，list filter: AbstractRequestLoggingFilter CharacterEncodingFilter CommonsRequestLoggingFilter CompositeFilter DelegatingFilterProxy GenericFilterBean HiddenHttpMethodFilter HttpPutFormContentFilter Log4jNestedDiagnosticContextFilter OncePerRequestFilter RequestContextFilter ServletContextRequestLoggingFilter ShallowEtagHeaderFilter 一、CharacterEncodingFilterCharacterEncodingFilter主要用于处理请求中的乱码问题。 这个类的继承关系如下： CharacterEncodingFilter的部分源码： 123456789101112131415161718public class CharacterEncodingFilter extends OncePerRequestFilter &#123; private String encoding; private boolean forceEncoding = false; @Override protected void doFilterInternal( HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; if (this.encoding != null &amp;&amp; (this.forceEncoding || request.getCharacterEncoding() == null)) &#123; request.setCharacterEncoding(this.encoding); if (this.forceEncoding) &#123; response.setCharacterEncoding(this.encoding); &#125; &#125; filterChain.doFilter(request, response); &#125;&#125; forceEncoding 为 true 为设置response的编码，并不会对request参数造成影响。 使用例子： 12345678910111213141516&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;","tags":[{"name":"Framework","slug":"Framework","permalink":"http://www.star45.xyz/tags/Framework/"},{"name":"Spring","slug":"Spring","permalink":"http://www.star45.xyz/tags/Spring/"}]},{"title":"Spring系列1-Filter","date":"2017-03-12T04:02:45.000Z","path":"2017/03/12/spring/Spring系列/","text":"![spring.png] Spring Framework 是一个开源的Java／Java EE全功能栈（full-stack）的应用程序框架，以Apache许可证形式发布，也有.NET平台上的移植版本。该框架基于 Expert One-on-One Java EE Design and Development（ISBN 0-7645-4385-7）一书中的代码，最初由Rod Johnson和Juergen Hoeller等开发。Spring Framework提供了一个简易的开发方式，这种开发方式，将避免那些可能致使底层代码变得繁杂混乱的大量的属性文件和帮助类。 SpringFramework系列, SpringFrameworkSpring是什么 我们为什么要用SpringFramework SpringFramework会给我们带来什么","tags":[{"name":"Framework","slug":"Framework","permalink":"http://www.star45.xyz/tags/Framework/"},{"name":"Spring","slug":"Spring","permalink":"http://www.star45.xyz/tags/Spring/"}]},{"title":"github维护","date":"2017-01-11T10:12:17.000Z","path":"2017/01/11/工具/github维护/","text":"关于github的学习管理 github的一些操作 一、建立项目二、导入项目三、使用git维护四、编写readme.md1、使用MarkDown2、个性的图标http://shields.io/ 项目介绍 Star 项目版本 项目构建 项目覆盖 项目许可 项目下载","tags":[{"name":"Github","slug":"Github","permalink":"http://www.star45.xyz/tags/Github/"}]},{"title":"Linux下shell脚本执行jar文件","date":"2017-01-11T10:11:51.000Z","path":"2017/01/11/服务器/Linux下shell脚本执行jar文件/","text":"使用shell脚本执行一些命令 以下是具体的命令脚本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#!/bin/bash#description: 启动重启server服务 #端口号，根据此端口号确定PID PORT=9997 #启动命令所在目录 HOME=&apos;/usr/etc/server/java/server&apos; #查询出监听了PORT端口TCP协议的程序 pid=`netstat -anp|grep $PORT|awk &apos;&#123;printf $7&#125;&apos;|cut -d/ -f1` start()&#123; if [ -n &quot;$pid&quot; ]; then echo &quot;server already start,pid:$pid&quot; return 0 fi #进入命令所在目录 cd $HOME nohup java -jar $HOME/pserver9997.jar &gt; $HOME/server.log 2&gt;&amp;1 &amp; #启动聊天服务器 把日志输出到HOME目录的server.log文件中 echo &quot;start at port:$PORT&quot; &#125; stop()&#123; if [ -z &quot;$pid&quot; ]; then echo &quot;not find program on port:$PORT&quot; return 0 fi #结束程序，使用讯号2，如果不行可以尝试讯号9强制结束 kill -9 $pid rm -rf $pid echo &quot;kill program use signal 2,pid:$pid&quot; &#125; status()&#123; if [ -z &quot;$pid&quot; ]; then echo &quot;not find program on port:$PORT&quot; else echo &quot;program is running,pid:$pid&quot; fi &#125; case $1 in start) start ;; stop) stop ;; restart) $0 stop sleep 2 $0 start ;; status) status ;; *) echo &quot;Usage: &#123;start|stop|status&#125;&quot; ;; esac exit 0","tags":[{"name":"Linux","slug":"Linux","permalink":"http://www.star45.xyz/tags/Linux/"}]},{"title":"Sublime Text 3 《第四章 - 插件》","date":"2017-01-11T10:11:25.000Z","path":"2017/01/11/工具/Sublime-Text-3-《第四章-插件》/","text":"工欲善其事，必先利其器四、Sublime Text 3 插件详解 插件列表: SideBarEnhancements : 左侧菜单栏 Anaconda : Python集成插件 ConvertToUTF8 : 非utf8文本自动转换 BetterCoffeeScript : Coffee支持 emmet : ZenCoding Markdown preview : markdown预览 MarkdownEditing : markdown高亮 Gutter Color : 显示颜色，需要先运行brew install ImageMagick terminal : 直接打开终端 Git : 直接使用Git命令(当然要先有git) 各种格式化的插件就按照自己的需求选装吧 安装完成后，一个绝对不会卡的轻便IDE就完成了！ 1、SublimeTmpl Sublime Text 新建文件的模版插件: SublimeTmpl写了个sublime的模版插件, 项目主页: https://github.com/kairyou/SublimeTmpl 这样就可以新建文件时使用模版的内容了, 目前添加了 1* html js css php python ruby 六种模版. 不需新建空白文件, 再从其他文件复制内容过来了. 已增加对Sublime Text3的支持. 使用: 11. ST菜单, File-New File (SublimeTmpl), 选择列表里的相应菜单, 可直接使用模版新建文件. 命令, cmd+shift+p, 输入: “tmpl:”, 可以找到创建文件的菜单列表. 快捷键, 默认快捷键见下面. 可以自己修改, 方法见”设置”部分. 默认快捷键: | 快捷键 | 目标文件 || — | — || ctrl+alt+h | html || ctrl+alt+j | javascript || ctrl+alt+c | css || ctrl+alt+p | php || ctrl+alt+r | ruby || ctrl+alt++shift+p | python | 安装: 11\\. 方法1\\. 通过 Package Control Package Control / Install Package, 搜索”SublimeTmpl” 或 “tmpl”, 安装.已经通过Package Control审核 12\\. 方法2\\. Github 打开项目主页, Git clone到ST的Packages文件夹(\\Data\\Packages), 或直接把ZIP格式的下载下来解压到Packages文件夹(文件夹名称必须为:SublimeTmpl). 设置: 菜单: Preferences / Packages Settings / SublimeTmpl, 可以编辑菜单/快捷键/新语法等等. 如果你想贡献自己的package, 可以参考我这篇文章的介绍:http://www.fantxi.com/blog/archives/how-to-submit-a-sublime-package/ 新增特性: 11. 用户自定义模板 (Thanks @Xu Cheng Github) 自定义模板路径: “Data\\Packages\\User\\SublimeTmpl\\templates” 目录, 会优先使用.默认模版路径: “Data\\Packages\\SublimeTmpl\\templates” 目录.用自己自定义的模板: 推荐把默认模版目录的*.tmpl文件 复制到 自定义模板路径, 再去修改. 12. 模板支持 $&#123;date&#125; 变量 settings - user里面可以修改${date}默认的输出格式(“%Y-%m-%d %H:%M:%S”), 比如改成: “date_format” : “%Y-%m-%d” 13\\. 模板支持自定义 attr settings - user里添加: 12345&quot;attr&quot;: &#123;&quot;author&quot;: &quot;your name&quot; ,&quot;email&quot;: &quot;mail@yours.com&quot;,&quot;link&quot;: &quot;http://yours.com&quot;,&quot;hello&quot;: &quot;word&quot; }`就能在模板中使用 author{email} link{hello} 变量Thanks @vfasky (Blog) 另外, 关于新增语言的附加说明 11\\. 新增SublimeTmpl里面没有的语言 首先请看: Packages Settings / SublimeTmpl / Settings - Default 的默认语法设置.如果要新增语法, 请选择: SublimeTmpl / Settings - User, 内容格式参考Settings - Default的内容, 比如新增两个语言test和yours: ` { &quot;test&quot;: {&quot;syntax&quot;: &quot;Packages/test/test.tmLanguage&quot;}, &quot;yours&quot;: {&quot;syntax&quot;: &quot;Packages/Yours/Yours.tmLanguage&quot;} } ` ` 新增开始菜单: 可以在SublimeTmpl / Settings - Menu里, 参照其他语法增加test和yours. 新增快捷键: 可以编辑:SublimeTmpl / Key Bindings User( 格式参考: SublimeTmpl / Key Bindings Default) 新增Sublime的语言 1234567这个我也没新建过, 可以去Package Control或者github上面找个其他人添加的新语言, 参考参考.如果没找到别人写好的, 可以参考如下网址, 自己做:1. [官方文档][1], 利用AAAPackageDev这个插件制作2. [textmate的doc][2], 和sublime大部分是相同的3. [语法][3], 可以和自己新建的对比4. [详解][4]，很全面的教程 四、快捷键（只针对目前的软件） ctrl+alt+f格式化js代码 —— jsFormat tabhtml提示 ——- emmet 随心所欲的跳转Cmd+P之所以被叫做 Goto Anything 并不是虚名： 1* `Command+P` 可以快速跳转到当前项目中的任意文件，可进行关键词匹配。 Command+P后@(或是Command+R)可以快速列出/跳转到某个函数（很爽的是markdown 当中是匹配到标题，而且还是带缩进的！）。 Command+P后#可以在当前文件中进行搜索。 Command+P后 : (或是Ctrl+G)加上数字可以跳转到相应的行。而更酷的是你可以用Command+P加上一些关键词跳转到某个文件同时加上 @ 来列出/跳转到目标文件中的某个函数，或是同时加上 # 来在目标文件中进行搜索，或是同时加上 : 和数字来跳转到目标文件中相应的行。 以下是个人总结不完全的快捷键总汇，祝愿各位顺利解放自己的鼠标。 选择类 Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。 Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。 Ctrl+L 选中整行，继续操作则继续选择下一行，效果和Shift+↓ 效果一样。 Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。 Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。 Ctrl+M 光标移动至括号内结束或开始的位置。 Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。 Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。 Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。 Ctrl+Shift+] 选中代码，按下快捷键，展开代码。 Ctrl+K+0 展开所有折叠代码。 Ctrl+← 向左单位性地移动光标，快速移动光标。 Ctrl+→ 向右单位性地移动光标，快速移动光标。 shift+↑ 向上选中多行。 shift+↓ 向下选中多行。 Shift+← 向左选中文本。 Shift+→ 向右选中文本。 Ctrl+Shift+← 向左单位性地选中文本。 Ctrl+Shift+→ 向右单位性地选中文本。 Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。 Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。 Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。 Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类 Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。 Ctrl+Shift+D 复制光标所在整行，插入到下一行。 Tab 向右缩进。 Shift+Tab 向左缩进。 Ctrl+K+K 从光标处开始删除代码至行尾。 Ctrl+Shift+K 删除整行。 Ctrl+/ 注释单行。 Ctrl+Shift+/ 注释多行。 Ctrl+K+U 转换大写。 Ctrl+K+L 转换小写。 Ctrl+Z 撤销。 Ctrl+Y 恢复撤销。 Ctrl+U 软撤销，感觉和Gtrl+Z一样。 Ctrl+F2 设置书签 Ctrl+T 左右字母互换。 F6 单词检测拼写 搜索类 Ctrl+F 打开底部搜索框，查找关键字。 Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。 Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。 Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。 Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。 Ctrl+：打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。 Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。 Esc 退出光标多行选择，退出搜索框，命令框等。 显示类 Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。 Ctrl+PageDown 向左切换当前窗口的标签页。 Ctrl+PageUp 向右切换当前窗口的标签页。 Alt+Shift+1窗口分屏，恢复默认1屏（非小键盘的数字） Alt+Shift+2 左右分屏-2列 Alt+Shift+3 左右分屏-3列 Alt+Shift+4 左右分屏-4列 Alt+Shift+5 等分4屏 Alt+Shift+8 垂直分屏-2屏 Alt+Shift+9 垂直分屏-3屏 Ctrl+K+B 开启/关闭侧边栏。 F11 全屏模式 Shift+F11 免打扰模式 五、开发环境1、java开发环境2、Python开发环境 SublimeREPL，REPL就是read-evaluation-print-loop，解释型语言编译运行的过程）。装了SublimeREPL插件后也支持了编辑器上直接的编译运行和交互，但还是有一些不满的地方。SublimeREPL提供的功能当中有两个我比较常用的是运行Python交互环境和直接运行当前文件，而python自带的IDLE跟人性化的做法是把这两者结合起来，所以我想实现的是对当前的文件运行python的交互环境。 SublimeREPL 允许你在编辑界面直接运行 Python 解释器。我倾向于在单独的终端窗口用 bpython 来运行，但有时 SublimeREPL 是很有帮助的。 Pylinter 这个插件提供了目前我所见到的最好的 pylint 编辑器整合。它自动检查 .py 文件，无论其何时被保存，并且会直接在编辑界面显示 pylint 违规。它还有一个快捷方式来禁用局部的 pylint 检查，通过插入一个 #pylint: 禁用注释。这个插件对于我确实非常有用。 Anaconda绝对是换到Sublime Text 3后最令我兴奋的插件，没有之一。在Sublime Text 2的时代，为配置一个好用的python开发环境， 我们需要分别安装All Autocomplete,SublimeREPL,Pylinter和PEP8等诸多插件。 Geek就是让一切变得更简单，该插件作者就为了简便，把这些功能集中起来了。 Anaconda把PyFlakes, pep8 和 McCabe以插件的方式集成起来。安装Anaconda后，通过配置即可完成一个良好的Python开发环境。 3、markdown环境 markdown支持 http://www.ihunter.me/sublime-text-3%E4%B8%AD%E9%85%8D%E7%BD%AEmarkdown.html 4、git环境版本库是软件开发中不可缺少的工具，该插件把Git常用命令加入了Command Palette，让开发人员进行代码管理方便不少。 GitGutter这个小插件是在修改后的文件行号前增加一些标识图片，方便与版本库对比，修改内容一目了然。 Gist创建、管理gist的插件，Gist是GitHub提供的又一强力工具，用Git将用户常用的代码片段在线管理起来。安装此插件后，打开其User-Setting， 增加个人的GitHub访问Token后，即可通过快捷键或Console使用。","tags":[{"name":"工具","slug":"工具","permalink":"http://www.star45.xyz/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"http://www.star45.xyz/tags/Sublime-Text-3/"}]},{"title":"Sublime Text 3 《第三章 - 教程》","date":"2017-01-11T10:11:07.000Z","path":"2017/01/11/工具/Sublime-Text-3-《第三章-教程》/","text":"工欲善其事，必先利其器三、sublime Text3 教程 1、修改安装插件的位置 安装完sublime text3，在第一次运行的时候，sublime text3 会在%appdata%目录下生成一个Sublime Text 3的文件夹，用于存放配置文件，以及后面安装的各种插件(所以第一次打开sublime text3时会比较慢) 点击查看原图 要做的第一件事情就是把这个文件移动安装目录，便于设置完后打包。 第一步：安装完sublime text3后，不要直接运行。 找到sublime text3的安装目录，并在该目录下新建 Data 文件夹(注意大小写)。如果已经运行了，请先在地址栏输入 %appdata% 然后删除该目录下的sublime text3文件夹。 完成这一步之后再打开sublime text3所有的配置文件都会被生成在Data文件夹中了 点击查看原图 第二步：安装你需要的插件这就没什么好说的了，还是默认的安装方式。安装后的插件可以在sublime text3安装目录下的 Data/Packages下找到。 第三步：打包sublime text3文件夹打包的文件就可以在其他电脑上直接使用了。 2、注册 生成的密钥 密钥 12345678910111213----- BEGIN LICENSE -----Andrew WeberSingle User LicenseEA7E-855605813A03DD 5E4AD9E6 6C0EEB94 BC99798F942194A6 02396E98 E62C9979 4BB979FE91424C9D A45400BF F6747D88 2FB8807890F5CC94 1CDC92DC 8457107A F151657B1D22E383 A997F016 42397640 33F41CFCE1D0AE85 A0BBD039 0E9C8D55 E1B89D5D5CDB7036 E56DE1C0 EFCC0840 650CD3A6B98FC99C 8FAC73EE D2B95564 DF450523------ END LICENSE ------ 3、汉化4、配置 点击preferences－setting user，个人设置如下： 1234567891011121314151617181920212223242526&#123;//字体大小&quot;font_size&quot;: 13.0,//字体类型&quot;font_face&quot;: &quot;Consolas&quot;,// 设置每一行到顶部，以像素为单位的间距，效果相当于行距&quot;line_padding_top&quot;: 2,// 设置每一行到底部，以像素为单位的间距，效果相当于行距&quot;line_padding_bottom&quot;: 2,// html和xml下突出显示光标所在标签的两端，影响HTML、XML、CSS等&quot;match_tags&quot;: true, // 是否显示代码折叠按钮&quot;fold_buttons&quot;: true,// 代码提示&quot;auto_complete&quot;: true,// 默认编码格式&quot;default_encoding&quot;: &quot;UTF-8&quot;,// 左边边栏文件夹动画&quot;tree_animation_enabled&quot;: true,//删除你想要忽略的插件&quot;ignored_packages&quot;: [ &quot;Vintage&quot;, &quot;YUI Compressor&quot; ]&#125; 5、装插件 插件的安装方法有两个：直接安装和插件管理安装。 直接安装，将下载的安装包解压缩到Packages目录（菜单-&gt;preferences&gt;packages）； Package Control组件安装。用Package Control安装插件的方法： 按下Ctrl+Shift+P调出命令面板，输入install， 调出 Install Package 选项并回车，然后在列表中选中要安装的插件。 有的网络环境可能会不允许访问陌生的网络环境从而设置防火墙，而Sublime Text 貌似无法设置代理，可能就获取不到安装包列表了。 常用插件 Package Control（安装包控制） 打开Sublime Text ，按快捷键 ctrl+` 或者点击 Tools → Command Palette 调出控制台Console；将以下代码复制粘贴进命令行后回车： import urllib2,os;pf=’Package Control.sublime-package’;ipp=sublime.installed_packages_path();os.makedirs(ipp)ifnot os.path.exists(ipp)elseNone;open(os.path.join(ipp,pf),’wb’).write(urllib2.urlopen(‘http://sublime.wbond.net/‘+pf.replace(’ ‘,’%20’)).read()) 重新启动Sublime Text 3，如果在Preferences → Package Settings 中看到 Package Control 这一项，说明安装成功。 Alignment（代码补齐） 下载：https://github.com/wbond/sublime_alignment ColorPicker（调色盘） 下载：https://github.com/weslly/ColorPicker 在编辑CSS样式的时候，ColorPicker可以让sublime text 内置一个调色盘，调好颜色，点击OK就会在光标处生成十六进制颜色代码。 ColorPicker界面见图一 Zen Coding（现已改名为Emmet） 下载：https://github.com/sergeche/emmet-sublime 使用仿CSS选择器的语法来快速开发HTML和CSS，Zen Coding由两个核心组件组成：一个缩写扩展器(缩写为像CSS一样的选择器)和上下文无关的HTML标签对匹配器。 使用ZenCoding编写代码时，需要遵循一定的缩写规则： E元素名（div、p）； E#id带Id的元素（div#content、p#intro、span#error）； E.class带class的的元素（div.header、p.error）,id和class可以连着写，div#content.column E&gt;N子元素（div&gt;p、div#footer&gt;p&gt;span） EN多项元素（ul#nav&gt;li5&gt;a） E+N多项元素 E$*N带序号的元素 SublimeTmpl（自定义新建文件） 下载：https://github.com/kairyou/SublimeTmpl 默认已经添加了html、css、js等常见类型的面板，按ctrl+alt+h/ctrl+alt+c/ctrl+alt+j可新建这 3钟类型的文件，快捷键在这里\\Packages\\SublimeTmpl\\Default (Windows).sublime-keymap, 模板文件在这里\\Packages\\SublimeTmpl\\templates，可修改。 其他插件： Clipboard-history（粘贴板历史记录） 下载：https://github.com/kemayo/sublime-text-2-clipboard-history CSScomb（CSS属性排序） 下载：https://github.com/csscomb/CSScomb-for-Sublime Gits（集成 GitHub） 下载：https://github.com/kemayo/sublime-text-git Hex-to-HSL-Color Hex（颜色模式转HSL颜色模式） 下载：https://github.com/atadams/Hex-to-HSL-Color HtmlTidy（清理与排版你的HTML代码） 下载：https://github.com/welovewordpress/SublimeHtmlTidy JsFormat（javascript格式化） 下载：https://github.com/jdc0589/JsFormat PHPTidy（整理与排版PHP代码） 下载：https://github.com/welovewordpress/SublimePhpTidy SideBarEnhancements（侧边栏增强） 下载：https://github.com/titoBouzout/SideBarEnhancements SublimeLinter（代码错误提示） 下载：https://github.com/SublimeLinter/SublimeLinter/tree/sublime-text-3 SFTP（编辑 FTP 或 SFTP 服务器上的文件） 下载：http://wbond.net/sublime_packages/sftp Tradsim（中文繁字体和简体字转换） 下载：https://github.com/erinata/SublimeTradsim TrailingSpacer（高亮显示多余的空格和Tab） 下载：https://github.com/SublimeText/TrailingSpaces YUI Compressor（压缩JS和CSS文件） 下载：https://github.com/kairyou/SublimeYUICompressor 参考资料 http://www.imjeff.cn/blog/146/ http://blog.csdn.net/idxuanjun/article/details/13292847 http://my.oschina.net/theforever/blog/136554","tags":[{"name":"工具","slug":"工具","permalink":"http://www.star45.xyz/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"http://www.star45.xyz/tags/Sublime-Text-3/"}]},{"title":"Sublime Text 3 《第二章 - 介绍》","date":"2017-01-11T10:10:48.000Z","path":"2017/01/11/工具/Sublime-Text-3-《第二章-介绍》/","text":"工欲善其事，必先利其器二、Sublime Text 3 介绍 Sublime Text 是一个代码编辑器（Sublime Text 2是收费软件，但可以无限期试用），也是HTML和散文先进的文本编辑器。Sublime Text是由程序员Jon Skinner于2008年1月份所开发出来，它最初被设计为一个具有丰富扩展功能的Vim。Sublime Text具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。2012年6月26日推出新版本的Sublime Text 2.0，与之前版本相比主要有较大的改善：支持 Retina 视网膜屏、快速跳到下一个、文本拖放、改善构建系统、CSS 自动完成和高亮设置等。 以上的介绍是引用了百度百科上对Sublime text的解释。 SublimeText是一款非常精巧的文本编辑器，适合编写代码、做笔记、写文章。它用户界面十分整洁，功能非同凡响，性能快得出奇。 这些非常棒的特性 包括： 任意跳转（Goto Anything）、 多重选择（multiple selections）、 指令面板（command palette）、 免打扰模式（distraction free mode）、 分区编辑（split editing）、 快速项目切换（instant project switch）， 你还可以随意地自定义更多功能。 还有，这款编辑器支持Mac、Windows和Linux平台。 SublimeText本身已经非常强大，但是更棒的是有一长串的插件支持它，给它带来更强大的功能。 本文将介绍一些 Sublime Text 3 支持的热门插件（Sublime Text 2 的一些插件在 Sublime Text 3 上不支持）。 以下所讲到的安装包和插件下载地址","tags":[{"name":"工具","slug":"工具","permalink":"http://www.star45.xyz/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"http://www.star45.xyz/tags/Sublime-Text-3/"}]},{"title":"Sublime Text 3 《第一章 - 引入》","date":"2017-01-11T10:04:45.000Z","path":"2017/01/11/工具/Sublime-Text-3-《第一章-引入》/","text":"工欲善其事，必先利其器Sublime Text 3 引入 Sublime Text 3 一个如此性感无比的代码编辑器!程序员必备神器!跨平台… 以下所讲到的安装包和插件下载地址","tags":[{"name":"工具","slug":"工具","permalink":"http://www.star45.xyz/tags/工具/"},{"name":"Sublime Text 3","slug":"Sublime-Text-3","permalink":"http://www.star45.xyz/tags/Sublime-Text-3/"}]}]